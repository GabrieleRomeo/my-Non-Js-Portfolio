/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _lib = __webpack_require__("./src/js/lib.js");

	var _sideMenu = __webpack_require__("./src/components/sideMenu/sideMenu.js");

	var _sideMenu2 = _interopRequireDefault(_sideMenu);

	var _tab = __webpack_require__("./src/components/tab/tab.js");

	var _tab2 = _interopRequireDefault(_tab);

	var _card = __webpack_require__("./src/components/card/card.js");

	var _card2 = _interopRequireDefault(_card);

	var _email = __webpack_require__("./src/components/email/email.js");

	var _email2 = _interopRequireDefault(_email);

	var _trivia = __webpack_require__("./src/components/trivia/trivia.js");

	var _trivia2 = _interopRequireDefault(_trivia);

	var _documentReady = __webpack_require__("./src/js/document-ready.js");

	var _documentReady2 = _interopRequireDefault(_documentReady);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var rcompose = _lib.lib.rcompose;


	function main() {
	  var ANIM = _lib.Portfolio.Animation.scrolling;
	  var DOM = _lib.Portfolio.Utils.Dom;
	  var COOKIES = _lib.Portfolio.Utils.cookies;
	  var $ = DOM.$;
	  var $$ = DOM.$$;

	  var throttleInterval = 500;
	  var isScrolled = true;
	  var lastScrollTop = 0;

	  var DOMcache = {
	    animation: $('.animation '),
	    header: $('#header'),
	    main: $(' [role="main"] '),
	    backToTop: $('#backToTop'),
	    sections: $$('main .c-section'),
	    sideMenuMobile: $('.c-sideMenu'),
	    sideMenuMobileTrigger: $('#hamburger__checkbox'),
	    sideMenuDesktop: $('.c-sideMenu--desktop'),
	    subMenuTrigger: $('#subMenu--trigger-1'),
	    projects: $('#projects'),
	    graphPaths: $$('.graph__path--front'),
	    card: $('.c-card'),
	    tab: $('.c-tab'),
	    scrollButton: $('.c-button--scroll'),
	    randomFactTrigger: $('.c-random-fact'),
	    emailButton: $('#button--contact')
	  };

	  function getSystemInformation() {
	    var viewPort = _lib.Portfolio.namespace('Utils').Window.viewPort();
	    var body = DOM.getBody();
	    var headerHeight = parseInt(DOM.getComputed(DOMcache.header)('height'));
	    return {
	      isLessThanDesktop: viewPort.width < '1024' ? true : false,
	      totalScroll: body.scrollTop + headerHeight,
	      VPST: viewPort.height + body.scrollTop,
	      VH: viewPort.height + body.scrollTop - headerHeight,
	      viewPort: viewPort,
	      body: body,
	      headerHeight: headerHeight
	    };
	  }

	  function handleClick(e) {
	    var target = null;
	    var classL = e.target.classList;
	    var element = void 0;

	    if (classL.contains('c-navigation__link') || classL.contains('c-sideMenu__link') || classL.contains('c-scroll')) {
	      target = e.target;
	    } else if (e.target.parentNode.classList.contains('c-scroll')) {
	      target = e.target.parentNode;
	    }

	    // Make sure that an intended element was clicked
	    if (!target) {
	      return;
	    }

	    element = $(target.hash);

	    ANIM.scrollTo(element, { ease: 'easeOutCubic', duration: 800 });
	  }

	  function setSideMenuItem(sysInfo) {
	    _sideMenu2.default.setCurrentItemByPosition(sysInfo.totalScroll);
	    return sysInfo;
	  }

	  function handleGOUpButton(sysInfo) {
	    var buttonVisibility = DOM.getComputed(DOMcache.backToTop)('visibility');
	    var isVisible = buttonVisibility && buttonVisibility === 'visible';

	    // On mobiles do nothing
	    if (sysInfo.isLessThanDesktop && isVisible) {
	      DOMcache.backToTop.style.visibility = 'hidden';
	    } else if (sysInfo.isLessThanDesktop) {
	      return;
	    }

	    /*
	     * Prevents the system to add or remove the same classes when unnecessary
	     * It does nothing when:
	     *
	     * The scrolled value is bigger than the Viewport's height and
	     * the button is already visible
	     *
	     * The scrolled value is lower than the Viewport's height and
	     * the button is already not visible
	     *
	     */
	    if (sysInfo.totalScroll > sysInfo.viewPort.height && isVisible) {
	      return;
	    } else if (sysInfo.totalScroll < sysInfo.viewPort.height && !isVisible) {
	      return;
	    }

	    if (sysInfo.totalScroll > sysInfo.viewPort.height) {
	      DOMcache.backToTop.style.visibility = 'visible';
	    } else {
	      DOMcache.backToTop.style.visibility = 'hidden';
	    }
	  }

	  function handleHeaderANDSideMenu(sysInfo) {
	    var ISUP = 'is-up';
	    var ISVISIBLE = 'is-visible';

	    // On Desktop it shows the header bar only when the viewport's height is
	    // lesser than the scrolling value minus the header's height
	    if (sysInfo.viewPort.height > sysInfo.VH) {
	      DOMcache.header.classList.remove(ISUP);
	      DOMcache.sideMenuDesktop.classList.remove(ISVISIBLE);
	      //return;
	    }

	    if (sysInfo.body.scrollTop > lastScrollTop && sysInfo.body.scrollTop > sysInfo.headerHeight) {
	      // Scroll Down
	      DOMcache.header.classList.add(ISUP);
	      DOMcache.sideMenuDesktop.classList.add(ISVISIBLE);
	    } else {
	      // Scroll Up
	      // On device less wider than Desktop it shows the header bar each
	      // time the user srolls up the page
	      if (sysInfo.isLessThanDesktop === true && sysInfo.viewPort.height <= sysInfo.VPST) {
	        DOMcache.header.classList.remove(ISUP);
	      }
	    }

	    // Update lastScrollTop
	    lastScrollTop = sysInfo.body.scrollTop;
	    return sysInfo;
	  }

	  function handleScroll() {
	    isScrolled = true;
	  }

	  function setCookie() {
	    var now = new Date();
	    var oneWeek = 1000 * 60 * 60 * 24 * 7;
	    var counter = COOKIES.get('counter');
	    var count = 0;

	    if (!counter || Number.isNaN(parseInt(counter))) {
	      count = 0;
	    } else {
	      count = parseInt(counter) + 1;
	    }

	    now.setTime(now.getTime() + oneWeek);

	    document.cookie = 'counter=' + count + ';expires=' + now.toUTCString();
	  }

	  var runSystem = rcompose(handleHeaderANDSideMenu, setSideMenuItem, handleGOUpButton);

	  window.setInterval(function () {
	    // Check if the page has been scrolled
	    if (isScrolled) {
	      var sysInfo = getSystemInformation();
	      runSystem(sysInfo);
	      isScrolled = false;
	    }
	  }, throttleInterval);

	  // Start custom actions
	  requestAnimationFrame(function () {
	    _email2.default.init();
	    _trivia2.default.init();
	    setCookie();
	  });

	  /***************************************************************************
	   *
	   *                         Events listeners
	   *
	   ***************************************************************************/

	  document.addEventListener('scroll', handleScroll, false);

	  DOMcache.header.addEventListener('click', handleClick, false);
	  DOMcache.scrollButton.addEventListener('click', handleClick, false);
	  DOMcache.sideMenuDesktop.addEventListener('click', handleClick, false);

	  DOMcache.sideMenuMobile.addEventListener('click', _sideMenu2.default.mobileClickHandler, false);

	  DOMcache.card.addEventListener('click', _card2.default, false);
	  DOMcache.emailButton.addEventListener('click', _email2.default.handleEmail, false);
	  DOMcache.tab.addEventListener('click', _tab2.default, false);

	  DOMcache.randomFactTrigger.addEventListener('click', _trivia2.default.handler, false);
	}

	// When DOM is ready, call the main function
	(0, _documentReady2.default)(main);

/***/ }),

/***/ "./src/js/document-ready.js":
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var documentReady = function documentReady() {
	  for (var _len = arguments.length, callbacks = Array(_len), _key = 0; _key < _len; _key++) {
	    callbacks[_key] = arguments[_key];
	  }

	  if (document.readyState === 'interactive' || document.readyState === 'complete') {
	    callbacks.forEach(function (cb) {
	      return cb();
	    });
	  } else {
	    callbacks.forEach(function (cb) {
	      return document.addEventListener('DOMContentLoaded', cb);
	    });
	  }
	};

	exports.default = documentReady;

/***/ }),

/***/ "../sjs/src/types.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.types = undefined;

	var _functional = __webpack_require__("../sjs/src/functional.js");

	var _functional2 = _interopRequireDefault(_functional);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**********************************************************************
	 *
	 *                     Default Type safety
	 *
	 * Using the typeOf function through the API, a user can define his/her
	 * data types
	 **********************************************************************/

	// Primitives

	/**
	 * Checks if the provided Data Type is a String. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {String} arg -  A string
	 * @returns {String} The same value without any changes.
	 * @example
	 * // returns 'Hello World'
	 * sjs.types.str('Hello World');
	 *
	 * // throws TypeError - Error: expected STRING but provided ARRAY
	 * sjs.types.str([]);
	 *
	 * // returns 'hello world'
	 * sjs.types.str('Hello World').toLowerCase();
	 */
	var str = typeOf('string');

	/**
	 * Checks if the provided Data Type is a Number. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Number} arg -  A Number (an Integer or a Float)
	 * @returns {Number} The same value without any changes.
	 * @example
	 * // returns 123.100
	 * sjs.types.num(123.100);
	 *
	 * // returns 5
	 * sjs.types.num(5);
	 *
	 * // throws TypeError - Error: expected NUMBER but provided ARRAY
	 * sjs.types.num([]);
	 */
	var num = typeOf('number');

	/**
	 * Checks if the provided Data Type is an Integer. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Integer} arg -  An Integer
	 * @returns {Integer} The same value without any changes.
	 * @example
	 * // returns 1
	 * sjs.types.int(1);
	 *
	 * // throws TypeError - Error: expected INTEGER but provided NUMBER
	 * sjs.types.int(2.2);
	 */
	var int = typeOf('integer');

	/**
	 * Checks if the provided Data Type is a Function. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Function} arg -  A Function
	 * @returns {Function} The same value without any changes.
	 * @example
	 * // returns function callback() {}
	 * sjs.types.fun(function callback() {});
	 *
	 * // throws TypeError - Error: expected FUNCTION but provided NUMBER
	 * sjs.types.fun(2);
	 */
	var fun = typeOf('function');

	/**
	 * Checks if the provided Data Type is a Boolean. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Boolean} arg -  A Boolean
	 * @returns {Boolean} The same value without any changes.
	 * @example
	 * // returns true
	 * sjs.types.bool(true);
	 *
	 * // throws TypeError - Error: expected BOOLEAN but provided STRING
	 * sjs.types.bool('Hi!');
	 */
	var bool = typeOf('boolean');

	/**
	 * Checks if the provided Data Type is a Date. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Date} arg -  A Date
	 * @returns {Date} The same value without any changes.
	 * @example
	 * // returns Tue Jan 31 2017 01:00:00 GMT+0100 (CET)
	 * sjs.types.date(new Date('2017-01-31'));
	 *
	 * // throws TypeError - Error: expected DATE but provided STRING
	 * sjs.types.date('hello');
	 */
	var date = typeOf('Date');

	/**
	 * Checks if the provided Data Type is an Object. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Object} arg -  An Object
	 * @returns {Object} The same value without any changes.
	 * @example
	 * // returns {number: 10, color: 'red'}
	 * sjs.types.obj({number: 10, color: 'red'});
	 *
	 * // throws TypeError - Error: expected OBJECT but provided DATE
	 * sjs.types.obj(new Date());
	 */
	var obj = typeOf('Object');

	/**
	 * Checks if the provided Data Type is an Array. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Array} arg -  An Array
	 * @returns {Array} The same value without any changes.
	 * @example
	 * // returns [1, 2, 4]
	 * sjs.types.arr([1, 2, 4]);
	 *
	 * // throws TypeError - Error: expected ARRAY but provided DATE
	 * sjs.types.arr(new Date());
	 */
	var arr = typeOf('Array');

	/**
	 * Checks if the provided Data Type is a Symbol. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Symbol} arg -  A Symbol
	 * @returns {Symbol} The same value without any changes.
	 * @example
	 * // returns Symbol(foo)
	 * sjs.types.sym(Symbol('foo'));
	 *
	 * // throws TypeError - Error: expected SYMBOL but provided STRING
	 * sjs.types.sym('symbol');
	 */
	var sym = typeOf('Symbol');

	/**
	 * Checks if the provided Data Type is a Regular Expression. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {RegExp} arg -  A RegExp
	 * @returns {RegExp} The same value without any changes.
	 * @example
	 * // returns /abc/i
	 * sjs.types.regex(/abc/i);
	 *
	 * // throws TypeError - Error: expected REGEXP but provided NUMBER
	 * sjs.types.regex(000);
	 */
	var regex = typeOf('RegExp');

	/**
	 * Checks if the provided Data Type is an HTML Node. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {Node} arg -  An HTML Node
	 * @returns {Node} The same value without any changes.
	 * @example
	 * // returns <body>...</body>
	 * sjs.types.HTMLNode(document.querySelector('body'));
	 *
	 * // throws TypeError - Error: expected HTMLNODE but provided NUMBER
	 * sjs.types.HTMLNode(10);
	 */
	var HTMLNode = typeOf('HtmlNode');

	/**
	 * Checks if the provided Data Type is an HTML NodeList. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {NodeList} arg -  An HTML NodeList
	 * @returns {NodeList} The same value without any changes.
	 * @example
	 * // returns a NodeList containing all the page's DIVs
	 * sjs.types.HTMLNodeList(document.querySelectorAll('DIV'));
	 *
	 * // throws TypeError - Error: expected NODELIST but provided NUMBER
	 * sjs.types.HTMLNodeList(10);
	 */
	var HTMLNodeList = typeOf('NodeList');

	/**
	 * Checks if the provided Data Type is a DocumentFragment. Otherwise the System
	 * throws a TypeError
	 * @memberof types
	 * @function
	 * @param {DocumentFragment} arg -  A DocumentFragment
	 * @returns {DocumentFragment} The same value without any changes.
	 * @example
	 * // returns #document-fragment
	 * sjs.types.HTMLFragment(document.createDocumentFragment());
	 *
	 * // throws TypeError - Error: expected DOCUMENTFRAGMENT but provided STRING
	 * sjs.types.HTMLFragment('document');
	 */
	var HTMLFragment = typeOf('DocumentFragment');

	/**
	  * Allows the User to define a new identity function for a custom Data Type
	  * @memberof types
	  * @param {String} - The Data Type's name
	  * @returns {Function} - A function which validates the custom Data Type
	  * @function
	  * @example
	  * const mutObserver = sjs.types.defineType('MutationObserver');
	  *
	  * // Somewhere in your code, you can check if the provided argument is
	  * // of the intended type
	  * function list(Array, Observer) {
	  *   Array = sjs.types.arr(Array);
	  *   Observer = mutObserver(Observer);
	  *   // ...
	  * }
	  */
	var defineType = function defineType(t) {
	  return typeOf(t);
	};

	/**
	  * Provides the User s way to specify a list of allowed Data Types for a specific
	  * argument.
	  * @memberof types
	  * @function
	  * @param {String} - A list of allowed Data Types
	  * @returns {Function} - A function which validates the allowed Data Types
	  * @example
	  * function checkDate(value) {
	  *   const types = sjs.allowedTypes('String', 'Date');
	  *   // value must be a String or a Date
	  *   const date = new Date(types(value));
	  *   return date;
	  * }
	  */
	var allowedTypes = function allowedTypes() {
	  for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
	    types[_key] = arguments[_key];
	  }

	  return typeOf(types);
	};

	/*
	 * Given a data type, it returns a function that, when applied, checks if
	 * the provide value is of the intended data type
	 */
	function typeOf(types) {
	  return function (x) {
	    var HTMLTest = /HTML.*Element/i;
	    var INTEGERTest = /^-?[0-9]*$/g;
	    var expected = [].concat(types).map(_functional2.default.capitalize);
	    var provided = _functional2.default.capitalize(_functional2.default.classOf(x));

	    if (expected.includes('HTMLNODE') && HTMLTest.test(provided) || expected.includes('INTEGER') && _functional2.default.classOf(x) === 'Number' && INTEGERTest.test(x) || expected.includes(provided)) {
	      return x;
	    } else {
	      throw new TypeError('\n        Error: expected ' + expected.join(' OR ') + ' but provided ' + provided + '\n        ');
	    }
	  };
	}

	/**
	 * Checks if all the items of an Array are of a particular DataType. If one of them
	 * is not valid, the function throws a TypeError
	 * @memberof types
	 * @function arrayOf
	 * @param {Function} fn -  A type validation function
	 * @returns {Function} Takes an Array and validate each item's datatype
	 * @param {Array} a - An Array of items
	 * @returns {Array} The provided Array
	 * @example
	 * // Since all items are numbers, it returns [1, 2, 3]
	 * sjs.types.arrayOf(sjs.types.num)([1, 2, 3]);
	 *
	 * // Since the last Array's item is the Null value,
	 * // it throws TypeError - Error: expected NUMBER but provided NULL
	 * sjs.types.arrayOf(sjs.types.num)([1, 2, 3, null]);
	 * @example <caption>Defining a list of Allowed Data Types</caption>
	 * const allowedTypes = sjs.types.allowedTypes('String', 'Integer');
	 * // Since all items satisfy the requirement, it returns [1, 2, 3, 'Hello World']
	 * sjs.types.arrayOf(allowedTypes)([1, 2, 3, 'Hello World']);
	 *
	 * // Since the second Array's item is a float number,
	 * // it throws TypeError - Error: expected STRING or INTEGER but provided NUMBER
	 * sjs.types.arrayOf(allowedTypes)([1, 2.2, 3, 'Hello World']);
	 *
	 * // Since the last Array's item is a nested Array,
	 * // it throws TypeError - Error: expected STRING or INTEGER but provided ARRAY
	 * sjs.types.arrayOf(allowedTypes)([1, 2, 3, 'Hello World', ['hi']]);
	 *
	 */
	var arrayOf = _functional2.default.arrayOf;

	/**
	 * This namespace provides a list of identity functions for common Data Types.
	 * You may use the available utilities to validate the argument(s) of a function.
	 * @namespace types
	 * @example <caption>Argument validation - Integer Data Type</caption>
	 * // The expected data type of a and b is an Integer
	 * function add(a, b) {
	 *    return sjs.types.int(a) + sjs.types.int(b);
	 * }
	 * @example <caption>Argument validation - Array Data Type</caption>
	 * // The expected data type is of the a argument is an Array
	 * function myFunc(a) {
	 *    return sjs.F.types.arr(a).reduce((prev, curr) => prev + curr, 0);
	 * }
	 */

	var types = exports.types = {
	  str: str,
	  num: num,
	  int: int,
	  bool: bool,
	  fun: fun,
	  date: date,
	  obj: obj,
	  arr: arr,
	  sym: sym,
	  regex: regex,
	  HTMLNode: HTMLNode,
	  HTMLNodeList: HTMLNodeList,
	  HTMLFragment: HTMLFragment,
	  defineType: defineType,
	  allowedTypes: allowedTypes,
	  arrayOf: arrayOf
	};

/***/ }),

/***/ "../sjs/src/functional.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _types = __webpack_require__("../sjs/src/types.js");

	/**
	 * The Functional Programming namespace.
	 * This namespace contains a list of functions written in functional style
	 * @namespace F
	 */
	var F = {};

	/******************************************************************************
	 *                        Functional Library Unit
	 * [Category Theory]
	 *
	 *  Categories ---> Sets composed from elements of the same types
	 *  Morphisms  ---> Pure functions that, given a set of specific inputs,
	 *                  they always return the same output
	 *
	 *  Functions:   1) Homomorphic - if limited to a single category
	 *               2) Polymorphic - if can operate on multiple categories
	 ******************************************************************************/

	/**
	 * Takes a Function with {N} parameters and splits it in a series of
	 * functions each taking a single argument. It allows you to provide an
	 * optional parameter 'n' which sets the function's arity.
	 * @memberof F
	 * @signature curry :: ((a, b) -> c) -> a -> b -> c
	 * @param {Function} fn A function to be curried
	 * @param {Integer}   n An optional integer representing the arity of the
	 *                      fn function
	 *
	 * @returns {Function} It returns a series of functions each taking a
	 *                     single argument.
	 * @example <caption>Provides the arguments to myFunction in 3 different steps</caption>
	 * const myFunction = (a, b, c) => 'a = ' + a + '; b = ' + b + '; c = ' + c;
	 *
	 * // Make myFunction a curried function
	 * const curriedFunction = sjs.F.curry(myFunction);
	 *
	 * var result = '';
	 *
	 * // Provide the first argument to the curried function
	 * result = curriedFunction('Hello');
	 *
	 * // Provide the second argument to the curried function
	 * result = result('World');
	 *
	 * // Provide the last argument to the curried function
	 * result = result('!!!');
	 *
	 * // returns "a = Hello; b = World; c = !!!"
	 *
	 * @example <caption>Provides the arguments in two steps</caption>
	 *
	 * var result = curriedFunction('Have', 'a');
	 * // returns "a = Have; b = a; c = good day!"
	 * result('good day!');
	 *
	 * @example <caption>Provides all the arguments in a single step</caption>
	 *
	 * // returns "a = Wow; b = It's; c = wonderful!"
	 * curriedFunction('Wow')('It\'s')('wonderful!');
	 *
	 * @example <caption>Specifies the Function's arity</caption>
	 * // The following function is Variadic because it takes a variable number of
	 * // arguments and returns the sum of them
	 * const sum = (...args) => args.reduce((a, b) => a + b, 0);
	 * // returns 49
	 * sum(3, 4, 5, 6, 10, 21);
	 *
	 *
	 * // The curried function will be applied when we provide at least 2 arguments
	 * // to it.
	 * const curriedSum = sjs.F.curry(sum);
	 * const curriedSumArity = sjs.F.curry(sum, 2);
	 *
	 * // returns TypeError
	 * curriedSum(3)(4);
	 *
	 * // returns 7
	 * curriedSumArity(3)(4);
	 */
	F.curry = function (fn, n) {
	  var arity = n || fn.length;

	  return function curried() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var context = this;

	    return args.length >= arity ? fn.apply(context, args) : function () {
	      for (var _len2 = arguments.length, remain = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        remain[_key2] = arguments[_key2];
	      }

	      return curried.apply(this, args.concat(remain));
	    };
	  };
	};

	/**
	 * Takes a Function with {N} parameters and splits it in a series of
	 * functions each taking a single argument. It allows you to provide an
	 * optional parameter 'n' which sets the function's arity. Unlike curry,
	 * rcurry curries a function's arguments from right to left.
	 * @memberof F
	 * @signature rcurry :: (Function, Integer) -> Function* -> a
	 * @param {Function} fn A function to be curried
	 * @param {Integer}   n An optional integer representing the arity of the
	 *                      fn function
	 *
	 * @returns {Function} It returns a series of functions each taking a
	 *                     single argument.
	 *
	 */
	F.rcurry = function (fn, n) {
	  return F.curry(F.flip(fn), n);
	};

	///////////////////////// FUNCTORS /////////////////////////

	/**
	  * Take a Function and an Array an applies the Function to each Array's item.
	  * @memberof F
	  * @signature map :: (a -> b) -> [a] -> [b]
	  * @param {Function} fn The function to be applied
	  * @param {Array} a An array of items
	  * @returns {Array} An array containing the mapped items
	  * @example
	  * const multiplyBy2 = n => n * 2;
	  * // returns [2, 4, 8, 12]
	  * sjs.F.map(multiplyBy2, [1, 2, 4, 6]);
	  */
	F.map = function (fn, a) {
	  return _types.types.arr(a).map(_types.types.fun(fn));
	};

	/**
	  * Checks if all the items of an Array are of a particular DataType. If one of them
	  * is not valid, the function throws a TypeError
	  * @memberof F
	  * @signature arrayOf :: (a -> b) -> ([a] -> [b])
	  * @param {Function} fn -  A type validation function
	  * @returns {Function} Takes an Array and validate each item's datatype
	  * @param {Array} a - An Array of items
	  * @returns {Array} The provided Array
	  * @example
	  * // Since all items are numbers, it returns [1, 2, 3]
	  * sjs.F.arrayOf(sjs.types.num)([1, 2, 3]);
	  *
	  * // Since the last Array's item is the Null value,
	  * // it throws TypeError - Error: expected NUMBER but provided NULL
	  * sjs.F.arrayOf(sjs.types.num)([1, 2, 3, null]);
	  * @example <caption>Defining a list of Allowed Data Types</caption>
	  * const allowedTypes = sjs.types.allowedTypes('String', 'Integer');
	  * // Since all items satisfy the requirement, it returns [1, 2, 3, 'Hello World']
	  * sjs.F.arrayOf(allowedTypes)([1, 2, 3, 'Hello World']);
	  *
	  * // Since the second Array's item is a float number,
	  * // it throws TypeError - Error: expected STRING or INTEGER but provided NUMBER
	  * sjs.F.arrayOf(allowedTypes)([1, 2.2, 3, 'Hello World']);
	  *
	  * // Since the last Array's item is a nested Array,
	  * // it throws TypeError - Error: expected STRING or INTEGER but provided ARRAY
	  * sjs.F.arrayOf(allowedTypes)([1, 2, 3, 'Hello World', ['hi']]);
	  *
	  */
	F.arrayOf = function (fn) {
	  return function (a) {
	    return F.map(_types.types.fun(fn), _types.types.arr(a));
	  };
	};

	/**
	  * It allows to build complex functions from many simple functions.
	  * Through composition, a function can be viewed as a building block for other
	  * functions.
	  * @memberof F
	  * @function
	  * @signature compose :: (b -> c) -> (a -> b) -> a -> c
	  * @example
	  * const add = (a, b) => a + b;
	  * const mul = (a, b) => a * b;
	  *
	  * const addAndMul = sjs.F.compose(add, mul);
	  * // returns 7 because mul is applied first, then 1 is added to the result
	  * // 2 * 3 = 6
	  * // 6 + 1
	  * addAndMul(2, 3)(1);
	  *
	  * // returns 5
	  * addAndMul(2, 3)(1);
	  */
	F.compose = function () {
	  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    args[_key3] = arguments[_key3];
	  }

	  // Checks that all the arguments are functions
	  var funcs = F.arrayOf(_types.types.fun)(args);

	  // returns a function that applies all the provided functions
	  return function () {
	    for (var _len4 = arguments.length, argsOfFuncs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      argsOfFuncs[_key4] = arguments[_key4];
	    }

	    var i = funcs.length - 1;
	    var fn = void 0;

	    do {
	      fn = F.curry.call(this, funcs[i]);
	      argsOfFuncs = [fn.apply(this, argsOfFuncs)];
	      i--;
	    } while (i >= 0);

	    return argsOfFuncs[0];
	  };
	};

	/**
	  * @memberof F
	  * @function
	  * @signature toArray :: a -> [a]
	  */
	F.toArray = function () {
	  for (var _len5 = arguments.length, a = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    a[_key5] = arguments[_key5];
	  }

	  return a;
	};

	/**
	  * Take a function and returns another function which takes a list of arguments
	  * and applies the first function to the arguments swapped in reverse order.
	  * @memberof F
	  * @function
	  * @signature flip :: (a -> b -> c) -> b -> a -> c
	  * @example
	  * const sub = (a, b) => a - b;
	  * // returns 2 (5 - 3)
	  * sub(5, 3);
	  *
	  * const flippedSub = sjs.F.flip(sub);
	  * // returns -2 (3 - 5)
	  * flippedSub(5, 3);
	  */
	F.flip = function (fn) {
	  return function () {
	    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	      args[_key6] = arguments[_key6];
	    }

	    return fn.apply(undefined, args.reverse());
	  };
	};

	/**
	  * As compose, It allows to build complex functions from many simple functions.
	  * Unlike compose, rcompose applies each composing functions from left to right.
	  * @memberof F
	  * @function
	  * @signature Function* -> a
	  * @signature rcompose :: (a -> b) -> (b -> c) -> a -> c
	  * @example
	  * const add = (a, b) => a + b;
	  * const mul = (a, b) => a * b;
	  *
	  * // Standard compose
	  * const addAndMul = sjs.F.compose(mul, add);
	  * // returns 5 because the add function is applied first then
	  * // the mul function. ((2 + 3) * 1)
	  * addAndMul(2, 3)(1);
	  *
	  * // Right compose
	  * const revMul = sjs.F.rcompose(mul, add);
	  * // returns 5 because the mul function is applied first then
	  * // the add function. ((2 * 3) + 1)
	  * revMul(2, 3)(1);
	  */
	F.rcompose = F.flip(F.compose);

	/**
	  * Tranform a String into Lowercase
	  * @memberof F
	  * @signature toLower :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The text in Lowercase
	  */
	F.toLower = function (s) {
	  return s.toLowerCase();
	};

	/**
	  * Tranform a String into Uppercase
	  * @memberof F
	  * @signature toUpper :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The text in Uppercase
	  */
	F.toUpper = function (s) {
	  return s.toUpperCase();
	};

	/**
	  * Take a String and capitalize its first word.
	  * @memberof F
	  * @signature capitalize :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The capitalized text
	  */
	F.capitalize = function (s) {
	  var a = F.toArray(s);
	  return F.toUpper(a[0]) + a.slice(1).join('');
	};

	/**
	  * Convert a function which takes n arguments into a function which takes
	  * just one argument
	  * @memberof F
	  * @function
	  * @signature unary :: Function -> Function
	  * @param {Function} fn A function taking n arguments
	  * @returns {Function} A function which takes just one argument
	  * @example
	  * // returns [2, NaN];
	  * ['2', '4'].map(parseInt);
	  *
	  * // returns [2, 4];
	  * ['2', '4'].map(sjs.F.unary(parseInt));
	  */
	F.unary = function (fn) {
	  return fn.length === 1 ? fn : function (arg) {
	    return fn(arg);
	  };
	};

	/**
	  * Executes a function just once
	  * @memberof F
	  * @function
	  * @signature once :: Function -> a
	  * @example
	  * // sjs.U.generateGUID generates a unique GUID
	  * const uniqueID = sjs.F.once(sjs.U.generateGUID);
	  * // returns a string like "63651124-d561-1897-36c8-53058d87519c"
	  * uniqueID();
	  *
	  * // return undefined
	  * uniqueID();
	  *
	  * // return undefined
	  * uniqueID();
	  */
	F.once = function (fn) {
	  var done = false;
	  return function () {
	    return done ? undefined : (done = true, fn.apply(this, arguments));
	  };
	};

	/**
	  * @memberof F
	  * @function
	  * @signature getWith :: String -> Object -> a
	  */
	F.getWith = function (property) {
	  return function (object) {
	    return object[property];
	  };
	};

	/**
	  * @memberof F
	  * @function
	  */
	F.forEachObject = function (obj, fn) {
	  for (var property in obj) {
	    if (obj.hasOwnProperty(property)) {
	      // calls the fn function with key and value as its arguments
	      fn(property, obj[property]);
	    }
	  }
	};

	/**
	  * Take a predicate and a Function and Apply the function only when the predicate
	  * is false
	  * @memberof F
	  * @function
	  * @signature (bool, Function) -> a
	  * @param {Bool} predicate The predicate
	  * @param {Function} fn A function to be applied when the predicate is false
	  * @returns {Any} The result of the applied function
	  * @example
	  * const list = [
	  *   { disabled: false, name: 'Action 1' },
	  *   { disabled: true, name: 'Action 2' },
	  *   { disabled: false, name: 'Action 3' },
	  * ];
	  *
	  * // returns
	  * // {disabled: false, name: "Action 1"} "is disabled"
	  * // {disabled: false, name: "Action 3"} "is disabled"
	  * list.forEach(item => {
	  *   sjs.F.unless(item.disabled, () => console.log(item, 'is disabled'));
	  * });
	  */
	F.unless = function (predicate, fn) {
	  if (!predicate) {
	    fn();
	  }
	};

	/**
	  * Returns the first item of an Array
	  * @memberof F
	  * @signature head :: Array -> a
	  * @param {Array} a An Array
	  * @returns {Any} The first item
	  */
	F.head = function (a) {
	  return _types.types.arr(a)[0];
	};

	/**
	  * Returns an Array containing all the items starting from the second item
	  * (default).
	  * @memberof F
	  * @signature tail :: (Array, Integer) -> Array
	  * @param {Array} a An Array
	  * @param {Integer} [begin = 1] The first item of the resulting array
	  * @returns {Array} An array containing a portion of the original array
	  */
	F.tail = function (a) {
	  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  return _types.types.arr(a).slice(_types.types.int(begin), a.length);
	};

	/**
	  * Given a property's name and a two object, it returns:<br>
	  * -1 if the property's length of the object 1 is lesser than that of object 2<br>
	  * 1  if both the lengths are equal<br>
	  * 0 if the property's length of the object 1 is grather than that of object 2<br>
	  * @memberof F
	  * @signature String -> (a, b) -> Integer
	  * @param {String} property The property's name
	  * @returns {Function} A function which takes two object
	  * @param {Object} a The first object
	  * @param {Object} b The second object
	  * @returns {Integer} -1, 1, 0
	  * @example
	  * const cars = [
	  *   { name: 'Ferrari', color: 'red' },
	  *   { name: 'Lamborghini', color: 'black' },
	  *   { name: 'Porsche', color: 'green' }
	  * ];
	  *
	  * // returns [
	  * //  { name: 'Lamborghini', color: 'black' },
	  * //  { name: 'Porsche', color: 'green' },
	  * //  { name: 'Ferrari', color: 'red' }
	  * // ];
	  * cars.sort(sjs.F.sortBy('color'));
	  *
	  * // returns [
	  * //  { name: 'Ferrari', color: 'red' }
	  * //  { name: 'Lamborghini', color: 'black' },
	  * //  { name: 'Porsche', color: 'green' },
	  * // ];
	  * cars.sort(sjs.F.sortBy('name'));
	  */
	F.sortBy = function (property) {
	  return function (a, b) {
	    var r = a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
	    return r;
	  };
	};

	/**
	  * Concatenate nested arrays (1 level depth) into a single array
	  * @memberof F
	  * @signature flatten :: Array -> Array
	  * @param {Array} a An array containing nested arrays
	  * @returns {Array} A flatten array
	  * @example
	  * // returns [1, 2, 3]
	  * sjs.F.flatten([[1], 2, 3]);
	  */
	F.flatten = function (array) {
	  return array.reduce(function (p, n) {
	    return p.concat(n);
	  }, []);
	};

	/**
	  * Concatenate multiple nested arrays into a single array
	  * @memberof F
	  * @signature unfold :: Array -> Array
	  * @param {Array} a An array containing possible nested arrays in multiple levels
	  * @returns {Array} A flatten array
	  * @example <caption>On level depth</caption>
	  * // returns [1, 2, 3]
	  * sjs.F.unfold([[1], 2, 3]);
	  * @example <caption>Multiple levels</caption>
	  * // returns [1, 2, 3, 4, 5]
	  * sjs.F.unfold([1, 2, [3, [4, [5]]]]);
	  */
	F.unfold = function (array) {
	  var inner = function inner(a) {
	    return F.hold(a, Array.isArray) ? inner(F.flatten(a)) : a;
	  };
	  return inner(array);
	};

	/**
	  * Merge two arrays and apply a callback function
	  * @memberof F
	  * @signature zip :: (Array, Array, Function) -> Array
	  * @param {Array} leftArray The left array
	  * @param {Array} rightArray The right array
	  * @param {Function} fn A callback function
	  * @returns {Array} A merged array
	  */
	F.zip = function (leftArray, rightArray, fn) {
	  var result = [];
	  var leftLength = leftArray.length;
	  var rightLength = rightArray.length;

	  for (var i = 0; i < Math.min(leftLength, rightLength); i++) {
	    result.push(fn(leftArray[i], rightArray[i]));
	  }
	  return result;
	};

	/**
	  * Apply a function n times.
	  * @memberof F
	  * @function
	  * @signature times :: (Integer, (Integer -> b)) -> b
	  * @example
	  * sjs.F.times(10, n => {
	  *   console.log(n % 2);
	  * });
	  */
	F.times = function (times, fn) {
	  for (var i = 0; i < times; i++) {
	    fn(i);
	  }
	};

	/**
	  * Allow a Function to remember or memorize its result.
	  * @memberof F
	  * @function
	  * @signature memoized :: Function -> (a) -> a
	  * @param {Function} fn The Function you wish to work with
	  * @returns {Function} A Function
	  * @param {Any} arg An argument to memorize
	  * @returns {Any} The result of applying the argument to the fn Function
	  */
	F.memoized = function (fn) {
	  var lookupTable = {};
	  return function (arg) {
	    return lookupTable[arg] || (lookupTable[arg] = fn(arg));
	  };
	};

	/**
	  * Negate a predicate
	  * @memberof F
	  * @function
	  * @signature not :: bool -> bool
	  * @param {Bool} x A predicate
	  * @returns {Bool} The negation of x
	  */
	F.not = function (x) {
	  return !_types.types.bool(x);
	};

	/**
	  * asyncAction :: Function -> Function
	  * @memberof F
	  * @function
	  */
	F.asyncAction = function (action) {
	  action = _types.types.fun(action);
	  return function (context) {
	    for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
	      args[_key7 - 1] = arguments[_key7];
	    }

	    return window.requestAnimationFrame(function () {
	      return action.apply(context, args);
	    });
	  };
	};

	/**
	 * It calls the 'fn' function if and only if the provided parameters
	 * are neither null nor undefined
	 * @memberof F
	 * @signature maybe :: b -> (a -> b) -> Maybe a -> b
	 *
	 * @param {Function} fn The function that could be applied
	 *
	 * @returns {(value | undefined)} The fn's evalutation or undefined
	 */
	F.maybe = function (fn) {
	  return function () {

	    var i,
	        len = arguments.length;

	    if (len === 0) {
	      return void 0;
	    } else {

	      for (i = 0; i < len; i++) {
	        if (!arguments[i]) return void 0;
	      }
	      // If all the parameters were provided to the original function,
	      // applies it
	      return fn.apply(this, arguments);
	    }
	  };
	};

	/**
	 * Provides the actual dataType of the provided argument
	 * @signature classOf :: a -> String
	 * @memberof F
	 *
	 * @param      {value}  value  The value under test
	 * @return     {string}  The datatype's name
	 * @example
	 * // returns "Number"
	 * sjs.F.classOf(5);
	 * @example
	 * // returns "Object"
	 * sjs.F.classOf({});
	 */
	F.classOf = function (value) {
	  if (value === null) {
	    return 'Null';
	  }
	  if (value === undefined) {
	    return 'Undefined';
	  }
	  return Object.prototype.toString.call(value).slice(8, -1);
	};

	/**
	 * Checks if the provided value is neither Null nor Undefined.
	 * @memberof F
	 * @signature exists :: a -> bool
	 *
	 * @param   {Any}  x    The value under test
	 * @return  {boolean}
	 */
	F.exists = function (x) {
	  return F.classOf(x) !== 'Null' && F.classOf(x) !== 'Undefined';
	};

	/**
	 * Check if the provided value is either Null or Undefined.
	 * @memberof F
	 * @signature notExists :: a -> bool
	 *
	 * @param   {Any}  x    The value under test
	 * @return  {boolean}
	 */
	F.notExists = function (x) {
	  return !F.exists(x);
	};

	/**
	 * Evaluate if a predicate holds for at least one item of an Array
	 * @memberof F
	 * @signature hold :: (Array, (a -> bool)) -> bool
	 *
	 * @param   {Array}  arr   An Array
	 * @param   {Function}  predicate   An predicate function
	 * @return  {boolean}
	 * @example
	 * // returns true
	 * sjs.F.hold([1, 2, [], 'a'], Array.isArray);
	 *
	 * // returns false
	 * sjs.F.hold([1, 2, [], 'a'], i => Object.prototype.toString.call(i) === '[object Null]');
	 */
	F.hold = function (arr, predicate) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var value = _step.value;

	      if (predicate(value)) return true;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return false;
	};

	/**
	 * Check if an object contains a specific key
	 * @memberof F
	 *
	 * @param   {Object}  object    The Object under test
	 * @param   {String}  x    The value under test
	 * @return  {String| Undefined}
	 * @example
	 * let obj = {
	 *  color: 'red'
	 * };
	 *
	 * // returns true
	 * sjs.F.contains(obj, 'color');
	 */
	F.contains = function (object, x) {
	  return F.exists(_types.types.obj(object)[x]);
	};

	exports.default = _extends({}, F);

/***/ }),

/***/ "../sjs/src/types.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.types = undefined;

	var _functional = __webpack_require__("../sjs/src/functional.js");

	var _functional2 = _interopRequireDefault(_functional);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**********************************************************************
	 *
	 *                     Default Type safety
	 *
	 * Using the typeOf function through the API, a user can define his/her
	 * data types
	 **********************************************************************/

	// Primitives

	/**
	 * Checks if the provided Data Type is a String. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {String} arg -  A string
	 * @returns {String} The same value without any changes.
	 * @example
	 * // returns 'Hello World'
	 * sjs.types.str('Hello World');
	 *
	 * // throws TypeError - Error: expected STRING but provided ARRAY
	 * sjs.types.str([]);
	 *
	 * // returns 'hello world'
	 * sjs.types.str('Hello World').toLowerCase();
	 */
	var str = typeOf('string');

	/**
	 * Checks if the provided Data Type is a Number. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Number} arg -  A Number (an Integer or a Float)
	 * @returns {Number} The same value without any changes.
	 * @example
	 * // returns 123.100
	 * sjs.types.num(123.100);
	 *
	 * // returns 5
	 * sjs.types.num(5);
	 *
	 * // throws TypeError - Error: expected NUMBER but provided ARRAY
	 * sjs.types.num([]);
	 */
	var num = typeOf('number');

	/**
	 * Checks if the provided Data Type is an Integer. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Integer} arg -  An Integer
	 * @returns {Integer} The same value without any changes.
	 * @example
	 * // returns 1
	 * sjs.types.int(1);
	 *
	 * // throws TypeError - Error: expected INTEGER but provided NUMBER
	 * sjs.types.int(2.2);
	 */
	var int = typeOf('integer');

	/**
	 * Checks if the provided Data Type is a Function. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Function} arg -  A Function
	 * @returns {Function} The same value without any changes.
	 * @example
	 * // returns function callback() {}
	 * sjs.types.fun(function callback() {});
	 *
	 * // throws TypeError - Error: expected FUNCTION but provided NUMBER
	 * sjs.types.fun(2);
	 */
	var fun = typeOf('function');

	/**
	 * Checks if the provided Data Type is a Boolean. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Boolean} arg -  A Boolean
	 * @returns {Boolean} The same value without any changes.
	 * @example
	 * // returns true
	 * sjs.types.bool(true);
	 *
	 * // throws TypeError - Error: expected BOOLEAN but provided STRING
	 * sjs.types.bool('Hi!');
	 */
	var bool = typeOf('boolean');

	/**
	 * Checks if the provided Data Type is a Date. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Date} arg -  A Date
	 * @returns {Date} The same value without any changes.
	 * @example
	 * // returns Tue Jan 31 2017 01:00:00 GMT+0100 (CET)
	 * sjs.types.date(new Date('2017-01-31'));
	 *
	 * // throws TypeError - Error: expected DATE but provided STRING
	 * sjs.types.date('hello');
	 */
	var date = typeOf('Date');

	/**
	 * Checks if the provided Data Type is an Object. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Object} arg -  An Object
	 * @returns {Object} The same value without any changes.
	 * @example
	 * // returns {number: 10, color: 'red'}
	 * sjs.types.obj({number: 10, color: 'red'});
	 *
	 * // throws TypeError - Error: expected OBJECT but provided DATE
	 * sjs.types.obj(new Date());
	 */
	var obj = typeOf('Object');

	/**
	 * Checks if the provided Data Type is an Array. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Array} arg -  An Array
	 * @returns {Array} The same value without any changes.
	 * @example
	 * // returns [1, 2, 4]
	 * sjs.types.arr([1, 2, 4]);
	 *
	 * // throws TypeError - Error: expected ARRAY but provided DATE
	 * sjs.types.arr(new Date());
	 */
	var arr = typeOf('Array');

	/**
	 * Checks if the provided Data Type is a Symbol. Otherwise the System throws a
	 * TypeError
	 * @memberof types
	 * @function
	 * @param {Symbol} arg -  A Symbol
	 * @returns {Symbol} The same value without any changes.
	 * @example
	 * // returns Symbol(foo)
	 * sjs.types.sym(Symbol('foo'));
	 *
	 * // throws TypeError - Error: expected SYMBOL but provided STRING
	 * sjs.types.sym('symbol');
	 */
	var sym = typeOf('Symbol');

	/**
	 * Checks if the provided Data Type is a Regular Expression. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {RegExp} arg -  A RegExp
	 * @returns {RegExp} The same value without any changes.
	 * @example
	 * // returns /abc/i
	 * sjs.types.regex(/abc/i);
	 *
	 * // throws TypeError - Error: expected REGEXP but provided NUMBER
	 * sjs.types.regex(000);
	 */
	var regex = typeOf('RegExp');

	/**
	 * Checks if the provided Data Type is an HTML Node. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {Node} arg -  An HTML Node
	 * @returns {Node} The same value without any changes.
	 * @example
	 * // returns <body>...</body>
	 * sjs.types.HTMLNode(document.querySelector('body'));
	 *
	 * // throws TypeError - Error: expected HTMLNODE but provided NUMBER
	 * sjs.types.HTMLNode(10);
	 */
	var HTMLNode = typeOf('HtmlNode');

	/**
	 * Checks if the provided Data Type is an HTML NodeList. Otherwise the
	 * System throws a TypeError
	 * @memberof types
	 * @function
	 * @param {NodeList} arg -  An HTML NodeList
	 * @returns {NodeList} The same value without any changes.
	 * @example
	 * // returns a NodeList containing all the page's DIVs
	 * sjs.types.HTMLNodeList(document.querySelectorAll('DIV'));
	 *
	 * // throws TypeError - Error: expected NODELIST but provided NUMBER
	 * sjs.types.HTMLNodeList(10);
	 */
	var HTMLNodeList = typeOf('NodeList');

	/**
	 * Checks if the provided Data Type is a DocumentFragment. Otherwise the System
	 * throws a TypeError
	 * @memberof types
	 * @function
	 * @param {DocumentFragment} arg -  A DocumentFragment
	 * @returns {DocumentFragment} The same value without any changes.
	 * @example
	 * // returns #document-fragment
	 * sjs.types.HTMLFragment(document.createDocumentFragment());
	 *
	 * // throws TypeError - Error: expected DOCUMENTFRAGMENT but provided STRING
	 * sjs.types.HTMLFragment('document');
	 */
	var HTMLFragment = typeOf('DocumentFragment');

	/**
	  * Allows the User to define a new identity function for a custom Data Type
	  * @memberof types
	  * @param {String} - The Data Type's name
	  * @returns {Function} - A function which validates the custom Data Type
	  * @function
	  * @example
	  * const mutObserver = sjs.types.defineType('MutationObserver');
	  *
	  * // Somewhere in your code, you can check if the provided argument is
	  * // of the intended type
	  * function list(Array, Observer) {
	  *   Array = sjs.types.arr(Array);
	  *   Observer = mutObserver(Observer);
	  *   // ...
	  * }
	  */
	var defineType = function defineType(t) {
	  return typeOf(t);
	};

	/**
	  * Provides the User s way to specify a list of allowed Data Types for a specific
	  * argument.
	  * @memberof types
	  * @function
	  * @param {String} - A list of allowed Data Types
	  * @returns {Function} - A function which validates the allowed Data Types
	  * @example
	  * function checkDate(value) {
	  *   const types = sjs.allowedTypes('String', 'Date');
	  *   // value must be a String or a Date
	  *   const date = new Date(types(value));
	  *   return date;
	  * }
	  */
	var allowedTypes = function allowedTypes() {
	  for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
	    types[_key] = arguments[_key];
	  }

	  return typeOf(types);
	};

	/*
	 * Given a data type, it returns a function that, when applied, checks if
	 * the provide value is of the intended data type
	 */
	function typeOf(types) {
	  return function (x) {
	    var HTMLTest = /HTML.*Element/i;
	    var INTEGERTest = /^-?[0-9]*$/g;
	    var expected = [].concat(types).map(_functional2.default.capitalize);
	    var provided = _functional2.default.capitalize(_functional2.default.classOf(x));

	    if (expected.includes('HTMLNODE') && HTMLTest.test(provided) || expected.includes('INTEGER') && _functional2.default.classOf(x) === 'Number' && INTEGERTest.test(x) || expected.includes(provided)) {
	      return x;
	    } else {
	      throw new TypeError('\n        Error: expected ' + expected.join(' OR ') + ' but provided ' + provided + '\n        ');
	    }
	  };
	}

	/**
	 * Checks if all the items of an Array are of a particular DataType. If one of them
	 * is not valid, the function throws a TypeError
	 * @memberof types
	 * @function arrayOf
	 * @param {Function} fn -  A type validation function
	 * @returns {Function} Takes an Array and validate each item's datatype
	 * @param {Array} a - An Array of items
	 * @returns {Array} The provided Array
	 * @example
	 * // Since all items are numbers, it returns [1, 2, 3]
	 * sjs.types.arrayOf(sjs.types.num)([1, 2, 3]);
	 *
	 * // Since the last Array's item is the Null value,
	 * // it throws TypeError - Error: expected NUMBER but provided NULL
	 * sjs.types.arrayOf(sjs.types.num)([1, 2, 3, null]);
	 * @example <caption>Defining a list of Allowed Data Types</caption>
	 * const allowedTypes = sjs.types.allowedTypes('String', 'Integer');
	 * // Since all items satisfy the requirement, it returns [1, 2, 3, 'Hello World']
	 * sjs.types.arrayOf(allowedTypes)([1, 2, 3, 'Hello World']);
	 *
	 * // Since the second Array's item is a float number,
	 * // it throws TypeError - Error: expected STRING or INTEGER but provided NUMBER
	 * sjs.types.arrayOf(allowedTypes)([1, 2.2, 3, 'Hello World']);
	 *
	 * // Since the last Array's item is a nested Array,
	 * // it throws TypeError - Error: expected STRING or INTEGER but provided ARRAY
	 * sjs.types.arrayOf(allowedTypes)([1, 2, 3, 'Hello World', ['hi']]);
	 *
	 */
	var arrayOf = _functional2.default.arrayOf;

	/**
	 * This namespace provides a list of identity functions for common Data Types.
	 * You may use the available utilities to validate the argument(s) of a function.
	 * @namespace types
	 * @example <caption>Argument validation - Integer Data Type</caption>
	 * // The expected data type of a and b is an Integer
	 * function add(a, b) {
	 *    return sjs.types.int(a) + sjs.types.int(b);
	 * }
	 * @example <caption>Argument validation - Array Data Type</caption>
	 * // The expected data type is of the a argument is an Array
	 * function myFunc(a) {
	 *    return sjs.F.types.arr(a).reduce((prev, curr) => prev + curr, 0);
	 * }
	 */

	var types = exports.types = {
	  str: str,
	  num: num,
	  int: int,
	  bool: bool,
	  fun: fun,
	  date: date,
	  obj: obj,
	  arr: arr,
	  sym: sym,
	  regex: regex,
	  HTMLNode: HTMLNode,
	  HTMLNodeList: HTMLNodeList,
	  HTMLFragment: HTMLFragment,
	  defineType: defineType,
	  allowedTypes: allowedTypes,
	  arrayOf: arrayOf
	};

/***/ }),

/***/ "../sjs/src/functional.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _types = __webpack_require__("../sjs/src/types.js");

	/**
	 * The Functional Programming namespace.
	 * This namespace contains a list of functions written in functional style
	 * @namespace F
	 */
	var F = {};

	/******************************************************************************
	 *                        Functional Library Unit
	 * [Category Theory]
	 *
	 *  Categories ---> Sets composed from elements of the same types
	 *  Morphisms  ---> Pure functions that, given a set of specific inputs,
	 *                  they always return the same output
	 *
	 *  Functions:   1) Homomorphic - if limited to a single category
	 *               2) Polymorphic - if can operate on multiple categories
	 ******************************************************************************/

	/**
	 * Takes a Function with {N} parameters and splits it in a series of
	 * functions each taking a single argument. It allows you to provide an
	 * optional parameter 'n' which sets the function's arity.
	 * @memberof F
	 * @signature curry :: ((a, b) -> c) -> a -> b -> c
	 * @param {Function} fn A function to be curried
	 * @param {Integer}   n An optional integer representing the arity of the
	 *                      fn function
	 *
	 * @returns {Function} It returns a series of functions each taking a
	 *                     single argument.
	 * @example <caption>Provides the arguments to myFunction in 3 different steps</caption>
	 * const myFunction = (a, b, c) => 'a = ' + a + '; b = ' + b + '; c = ' + c;
	 *
	 * // Make myFunction a curried function
	 * const curriedFunction = sjs.F.curry(myFunction);
	 *
	 * var result = '';
	 *
	 * // Provide the first argument to the curried function
	 * result = curriedFunction('Hello');
	 *
	 * // Provide the second argument to the curried function
	 * result = result('World');
	 *
	 * // Provide the last argument to the curried function
	 * result = result('!!!');
	 *
	 * // returns "a = Hello; b = World; c = !!!"
	 *
	 * @example <caption>Provides the arguments in two steps</caption>
	 *
	 * var result = curriedFunction('Have', 'a');
	 * // returns "a = Have; b = a; c = good day!"
	 * result('good day!');
	 *
	 * @example <caption>Provides all the arguments in a single step</caption>
	 *
	 * // returns "a = Wow; b = It's; c = wonderful!"
	 * curriedFunction('Wow')('It\'s')('wonderful!');
	 *
	 * @example <caption>Specifies the Function's arity</caption>
	 * // The following function is Variadic because it takes a variable number of
	 * // arguments and returns the sum of them
	 * const sum = (...args) => args.reduce((a, b) => a + b, 0);
	 * // returns 49
	 * sum(3, 4, 5, 6, 10, 21);
	 *
	 *
	 * // The curried function will be applied when we provide at least 2 arguments
	 * // to it.
	 * const curriedSum = sjs.F.curry(sum);
	 * const curriedSumArity = sjs.F.curry(sum, 2);
	 *
	 * // returns TypeError
	 * curriedSum(3)(4);
	 *
	 * // returns 7
	 * curriedSumArity(3)(4);
	 */
	F.curry = function (fn, n) {
	  var arity = n || fn.length;

	  return function curried() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var context = this;

	    return args.length >= arity ? fn.apply(context, args) : function () {
	      for (var _len2 = arguments.length, remain = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        remain[_key2] = arguments[_key2];
	      }

	      return curried.apply(this, args.concat(remain));
	    };
	  };
	};

	/**
	 * Takes a Function with {N} parameters and splits it in a series of
	 * functions each taking a single argument. It allows you to provide an
	 * optional parameter 'n' which sets the function's arity. Unlike curry,
	 * rcurry curries a function's arguments from right to left.
	 * @memberof F
	 * @signature rcurry :: (Function, Integer) -> Function* -> a
	 * @param {Function} fn A function to be curried
	 * @param {Integer}   n An optional integer representing the arity of the
	 *                      fn function
	 *
	 * @returns {Function} It returns a series of functions each taking a
	 *                     single argument.
	 *
	 */
	F.rcurry = function (fn, n) {
	  return F.curry(F.flip(fn), n);
	};

	///////////////////////// FUNCTORS /////////////////////////

	/**
	  * Take a Function and an Array an applies the Function to each Array's item.
	  * @memberof F
	  * @signature map :: (a -> b) -> [a] -> [b]
	  * @param {Function} fn The function to be applied
	  * @param {Array} a An array of items
	  * @returns {Array} An array containing the mapped items
	  * @example
	  * const multiplyBy2 = n => n * 2;
	  * // returns [2, 4, 8, 12]
	  * sjs.F.map(multiplyBy2, [1, 2, 4, 6]);
	  */
	F.map = function (fn, a) {
	  return _types.types.arr(a).map(_types.types.fun(fn));
	};

	/**
	  * Checks if all the items of an Array are of a particular DataType. If one of them
	  * is not valid, the function throws a TypeError
	  * @memberof F
	  * @signature arrayOf :: (a -> b) -> ([a] -> [b])
	  * @param {Function} fn -  A type validation function
	  * @returns {Function} Takes an Array and validate each item's datatype
	  * @param {Array} a - An Array of items
	  * @returns {Array} The provided Array
	  * @example
	  * // Since all items are numbers, it returns [1, 2, 3]
	  * sjs.F.arrayOf(sjs.types.num)([1, 2, 3]);
	  *
	  * // Since the last Array's item is the Null value,
	  * // it throws TypeError - Error: expected NUMBER but provided NULL
	  * sjs.F.arrayOf(sjs.types.num)([1, 2, 3, null]);
	  * @example <caption>Defining a list of Allowed Data Types</caption>
	  * const allowedTypes = sjs.types.allowedTypes('String', 'Integer');
	  * // Since all items satisfy the requirement, it returns [1, 2, 3, 'Hello World']
	  * sjs.F.arrayOf(allowedTypes)([1, 2, 3, 'Hello World']);
	  *
	  * // Since the second Array's item is a float number,
	  * // it throws TypeError - Error: expected STRING or INTEGER but provided NUMBER
	  * sjs.F.arrayOf(allowedTypes)([1, 2.2, 3, 'Hello World']);
	  *
	  * // Since the last Array's item is a nested Array,
	  * // it throws TypeError - Error: expected STRING or INTEGER but provided ARRAY
	  * sjs.F.arrayOf(allowedTypes)([1, 2, 3, 'Hello World', ['hi']]);
	  *
	  */
	F.arrayOf = function (fn) {
	  return function (a) {
	    return F.map(_types.types.fun(fn), _types.types.arr(a));
	  };
	};

	/**
	  * It allows to build complex functions from many simple functions.
	  * Through composition, a function can be viewed as a building block for other
	  * functions.
	  * @memberof F
	  * @function
	  * @signature compose :: (b -> c) -> (a -> b) -> a -> c
	  * @example
	  * const add = (a, b) => a + b;
	  * const mul = (a, b) => a * b;
	  *
	  * const addAndMul = sjs.F.compose(add, mul);
	  * // returns 7 because mul is applied first, then 1 is added to the result
	  * // 2 * 3 = 6
	  * // 6 + 1
	  * addAndMul(2, 3)(1);
	  *
	  * // returns 5
	  * addAndMul(2, 3)(1);
	  */
	F.compose = function () {
	  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    args[_key3] = arguments[_key3];
	  }

	  // Checks that all the arguments are functions
	  var funcs = F.arrayOf(_types.types.fun)(args);

	  // returns a function that applies all the provided functions
	  return function () {
	    for (var _len4 = arguments.length, argsOfFuncs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      argsOfFuncs[_key4] = arguments[_key4];
	    }

	    var i = funcs.length - 1;
	    var fn = void 0;

	    do {
	      fn = F.curry.call(this, funcs[i]);
	      argsOfFuncs = [fn.apply(this, argsOfFuncs)];
	      i--;
	    } while (i >= 0);

	    return argsOfFuncs[0];
	  };
	};

	/**
	  * @memberof F
	  * @function
	  * @signature toArray :: a -> [a]
	  */
	F.toArray = function () {
	  for (var _len5 = arguments.length, a = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    a[_key5] = arguments[_key5];
	  }

	  return a;
	};

	/**
	  * Take a function and returns another function which takes a list of arguments
	  * and applies the first function to the arguments swapped in reverse order.
	  * @memberof F
	  * @function
	  * @signature flip :: (a -> b -> c) -> b -> a -> c
	  * @example
	  * const sub = (a, b) => a - b;
	  * // returns 2 (5 - 3)
	  * sub(5, 3);
	  *
	  * const flippedSub = sjs.F.flip(sub);
	  * // returns -2 (3 - 5)
	  * flippedSub(5, 3);
	  */
	F.flip = function (fn) {
	  return function () {
	    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	      args[_key6] = arguments[_key6];
	    }

	    return fn.apply(undefined, args.reverse());
	  };
	};

	/**
	  * As compose, It allows to build complex functions from many simple functions.
	  * Unlike compose, rcompose applies each composing functions from left to right.
	  * @memberof F
	  * @function
	  * @signature Function* -> a
	  * @signature rcompose :: (a -> b) -> (b -> c) -> a -> c
	  * @example
	  * const add = (a, b) => a + b;
	  * const mul = (a, b) => a * b;
	  *
	  * // Standard compose
	  * const addAndMul = sjs.F.compose(mul, add);
	  * // returns 5 because the add function is applied first then
	  * // the mul function. ((2 + 3) * 1)
	  * addAndMul(2, 3)(1);
	  *
	  * // Right compose
	  * const revMul = sjs.F.rcompose(mul, add);
	  * // returns 5 because the mul function is applied first then
	  * // the add function. ((2 * 3) + 1)
	  * revMul(2, 3)(1);
	  */
	F.rcompose = F.flip(F.compose);

	/**
	  * Tranform a String into Lowercase
	  * @memberof F
	  * @signature toLower :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The text in Lowercase
	  */
	F.toLower = function (s) {
	  return s.toLowerCase();
	};

	/**
	  * Tranform a String into Uppercase
	  * @memberof F
	  * @signature toUpper :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The text in Uppercase
	  */
	F.toUpper = function (s) {
	  return s.toUpperCase();
	};

	/**
	  * Take a String and capitalize its first word.
	  * @memberof F
	  * @signature capitalize :: String -> String
	  * @param {String} s The text to be transformed
	  * @return {String} The capitalized text
	  */
	F.capitalize = function (s) {
	  var a = F.toArray(s);
	  return F.toUpper(a[0]) + a.slice(1).join('');
	};

	/**
	  * Convert a function which takes n arguments into a function which takes
	  * just one argument
	  * @memberof F
	  * @function
	  * @signature unary :: Function -> Function
	  * @param {Function} fn A function taking n arguments
	  * @returns {Function} A function which takes just one argument
	  * @example
	  * // returns [2, NaN];
	  * ['2', '4'].map(parseInt);
	  *
	  * // returns [2, 4];
	  * ['2', '4'].map(sjs.F.unary(parseInt));
	  */
	F.unary = function (fn) {
	  return fn.length === 1 ? fn : function (arg) {
	    return fn(arg);
	  };
	};

	/**
	  * Executes a function just once
	  * @memberof F
	  * @function
	  * @signature once :: Function -> a
	  * @example
	  * // sjs.U.generateGUID generates a unique GUID
	  * const uniqueID = sjs.F.once(sjs.U.generateGUID);
	  * // returns a string like "63651124-d561-1897-36c8-53058d87519c"
	  * uniqueID();
	  *
	  * // return undefined
	  * uniqueID();
	  *
	  * // return undefined
	  * uniqueID();
	  */
	F.once = function (fn) {
	  var done = false;
	  return function () {
	    return done ? undefined : (done = true, fn.apply(this, arguments));
	  };
	};

	/**
	  * @memberof F
	  * @function
	  * @signature getWith :: String -> Object -> a
	  */
	F.getWith = function (property) {
	  return function (object) {
	    return object[property];
	  };
	};

	/**
	  * @memberof F
	  * @function
	  */
	F.forEachObject = function (obj, fn) {
	  for (var property in obj) {
	    if (obj.hasOwnProperty(property)) {
	      // calls the fn function with key and value as its arguments
	      fn(property, obj[property]);
	    }
	  }
	};

	/**
	  * Take a predicate and a Function and Apply the function only when the predicate
	  * is false
	  * @memberof F
	  * @function
	  * @signature (bool, Function) -> a
	  * @param {Bool} predicate The predicate
	  * @param {Function} fn A function to be applied when the predicate is false
	  * @returns {Any} The result of the applied function
	  * @example
	  * const list = [
	  *   { disabled: false, name: 'Action 1' },
	  *   { disabled: true, name: 'Action 2' },
	  *   { disabled: false, name: 'Action 3' },
	  * ];
	  *
	  * // returns
	  * // {disabled: false, name: "Action 1"} "is disabled"
	  * // {disabled: false, name: "Action 3"} "is disabled"
	  * list.forEach(item => {
	  *   sjs.F.unless(item.disabled, () => console.log(item, 'is disabled'));
	  * });
	  */
	F.unless = function (predicate, fn) {
	  if (!predicate) {
	    fn();
	  }
	};

	/**
	  * Returns the first item of an Array
	  * @memberof F
	  * @signature head :: Array -> a
	  * @param {Array} a An Array
	  * @returns {Any} The first item
	  */
	F.head = function (a) {
	  return _types.types.arr(a)[0];
	};

	/**
	  * Returns an Array containing all the items starting from the second item
	  * (default).
	  * @memberof F
	  * @signature tail :: (Array, Integer) -> Array
	  * @param {Array} a An Array
	  * @param {Integer} [begin = 1] The first item of the resulting array
	  * @returns {Array} An array containing a portion of the original array
	  */
	F.tail = function (a) {
	  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  return _types.types.arr(a).slice(_types.types.int(begin), a.length);
	};

	/**
	  * Given a property's name and a two object, it returns:<br>
	  * -1 if the property's length of the object 1 is lesser than that of object 2<br>
	  * 1  if both the lengths are equal<br>
	  * 0 if the property's length of the object 1 is grather than that of object 2<br>
	  * @memberof F
	  * @signature String -> (a, b) -> Integer
	  * @param {String} property The property's name
	  * @returns {Function} A function which takes two object
	  * @param {Object} a The first object
	  * @param {Object} b The second object
	  * @returns {Integer} -1, 1, 0
	  * @example
	  * const cars = [
	  *   { name: 'Ferrari', color: 'red' },
	  *   { name: 'Lamborghini', color: 'black' },
	  *   { name: 'Porsche', color: 'green' }
	  * ];
	  *
	  * // returns [
	  * //  { name: 'Lamborghini', color: 'black' },
	  * //  { name: 'Porsche', color: 'green' },
	  * //  { name: 'Ferrari', color: 'red' }
	  * // ];
	  * cars.sort(sjs.F.sortBy('color'));
	  *
	  * // returns [
	  * //  { name: 'Ferrari', color: 'red' }
	  * //  { name: 'Lamborghini', color: 'black' },
	  * //  { name: 'Porsche', color: 'green' },
	  * // ];
	  * cars.sort(sjs.F.sortBy('name'));
	  */
	F.sortBy = function (property) {
	  return function (a, b) {
	    var r = a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
	    return r;
	  };
	};

	/**
	  * Concatenate nested arrays (1 level depth) into a single array
	  * @memberof F
	  * @signature flatten :: Array -> Array
	  * @param {Array} a An array containing nested arrays
	  * @returns {Array} A flatten array
	  * @example
	  * // returns [1, 2, 3]
	  * sjs.F.flatten([[1], 2, 3]);
	  */
	F.flatten = function (array) {
	  return array.reduce(function (p, n) {
	    return p.concat(n);
	  }, []);
	};

	/**
	  * Concatenate multiple nested arrays into a single array
	  * @memberof F
	  * @signature unfold :: Array -> Array
	  * @param {Array} a An array containing possible nested arrays in multiple levels
	  * @returns {Array} A flatten array
	  * @example <caption>On level depth</caption>
	  * // returns [1, 2, 3]
	  * sjs.F.unfold([[1], 2, 3]);
	  * @example <caption>Multiple levels</caption>
	  * // returns [1, 2, 3, 4, 5]
	  * sjs.F.unfold([1, 2, [3, [4, [5]]]]);
	  */
	F.unfold = function (array) {
	  var inner = function inner(a) {
	    return F.hold(a, Array.isArray) ? inner(F.flatten(a)) : a;
	  };
	  return inner(array);
	};

	/**
	  * Merge two arrays and apply a callback function
	  * @memberof F
	  * @signature zip :: (Array, Array, Function) -> Array
	  * @param {Array} leftArray The left array
	  * @param {Array} rightArray The right array
	  * @param {Function} fn A callback function
	  * @returns {Array} A merged array
	  */
	F.zip = function (leftArray, rightArray, fn) {
	  var result = [];
	  var leftLength = leftArray.length;
	  var rightLength = rightArray.length;

	  for (var i = 0; i < Math.min(leftLength, rightLength); i++) {
	    result.push(fn(leftArray[i], rightArray[i]));
	  }
	  return result;
	};

	/**
	  * Apply a function n times.
	  * @memberof F
	  * @function
	  * @signature times :: (Integer, (Integer -> b)) -> b
	  * @example
	  * sjs.F.times(10, n => {
	  *   console.log(n % 2);
	  * });
	  */
	F.times = function (times, fn) {
	  for (var i = 0; i < times; i++) {
	    fn(i);
	  }
	};

	/**
	  * Allow a Function to remember or memorize its result.
	  * @memberof F
	  * @function
	  * @signature memoized :: Function -> (a) -> a
	  * @param {Function} fn The Function you wish to work with
	  * @returns {Function} A Function
	  * @param {Any} arg An argument to memorize
	  * @returns {Any} The result of applying the argument to the fn Function
	  */
	F.memoized = function (fn) {
	  var lookupTable = {};
	  return function (arg) {
	    return lookupTable[arg] || (lookupTable[arg] = fn(arg));
	  };
	};

	/**
	  * Negate a predicate
	  * @memberof F
	  * @function
	  * @signature not :: bool -> bool
	  * @param {Bool} x A predicate
	  * @returns {Bool} The negation of x
	  */
	F.not = function (x) {
	  return !_types.types.bool(x);
	};

	/**
	  * asyncAction :: Function -> Function
	  * @memberof F
	  * @function
	  */
	F.asyncAction = function (action) {
	  action = _types.types.fun(action);
	  return function (context) {
	    for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
	      args[_key7 - 1] = arguments[_key7];
	    }

	    return window.requestAnimationFrame(function () {
	      return action.apply(context, args);
	    });
	  };
	};

	/**
	 * It calls the 'fn' function if and only if the provided parameters
	 * are neither null nor undefined
	 * @memberof F
	 * @signature maybe :: b -> (a -> b) -> Maybe a -> b
	 *
	 * @param {Function} fn The function that could be applied
	 *
	 * @returns {(value | undefined)} The fn's evalutation or undefined
	 */
	F.maybe = function (fn) {
	  return function () {

	    var i,
	        len = arguments.length;

	    if (len === 0) {
	      return void 0;
	    } else {

	      for (i = 0; i < len; i++) {
	        if (!arguments[i]) return void 0;
	      }
	      // If all the parameters were provided to the original function,
	      // applies it
	      return fn.apply(this, arguments);
	    }
	  };
	};

	/**
	 * Provides the actual dataType of the provided argument
	 * @signature classOf :: a -> String
	 * @memberof F
	 *
	 * @param      {value}  value  The value under test
	 * @return     {string}  The datatype's name
	 * @example
	 * // returns "Number"
	 * sjs.F.classOf(5);
	 * @example
	 * // returns "Object"
	 * sjs.F.classOf({});
	 */
	F.classOf = function (value) {
	  if (value === null) {
	    return 'Null';
	  }
	  if (value === undefined) {
	    return 'Undefined';
	  }
	  return Object.prototype.toString.call(value).slice(8, -1);
	};

	/**
	 * Checks if the provided value is neither Null nor Undefined.
	 * @memberof F
	 * @signature exists :: a -> bool
	 *
	 * @param   {Any}  x    The value under test
	 * @return  {boolean}
	 */
	F.exists = function (x) {
	  return F.classOf(x) !== 'Null' && F.classOf(x) !== 'Undefined';
	};

	/**
	 * Check if the provided value is either Null or Undefined.
	 * @memberof F
	 * @signature notExists :: a -> bool
	 *
	 * @param   {Any}  x    The value under test
	 * @return  {boolean}
	 */
	F.notExists = function (x) {
	  return !F.exists(x);
	};

	/**
	 * Evaluate if a predicate holds for at least one item of an Array
	 * @memberof F
	 * @signature hold :: (Array, (a -> bool)) -> bool
	 *
	 * @param   {Array}  arr   An Array
	 * @param   {Function}  predicate   An predicate function
	 * @return  {boolean}
	 * @example
	 * // returns true
	 * sjs.F.hold([1, 2, [], 'a'], Array.isArray);
	 *
	 * // returns false
	 * sjs.F.hold([1, 2, [], 'a'], i => Object.prototype.toString.call(i) === '[object Null]');
	 */
	F.hold = function (arr, predicate) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var value = _step.value;

	      if (predicate(value)) return true;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return false;
	};

	/**
	 * Check if an object contains a specific key
	 * @memberof F
	 *
	 * @param   {Object}  object    The Object under test
	 * @param   {String}  x    The value under test
	 * @return  {String| Undefined}
	 * @example
	 * let obj = {
	 *  color: 'red'
	 * };
	 *
	 * // returns true
	 * sjs.F.contains(obj, 'color');
	 */
	F.contains = function (object, x) {
	  return F.exists(_types.types.obj(object)[x]);
	};

	exports.default = _extends({}, F);

/***/ }),

/***/ "./src/js/lib.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.lib = exports.Portfolio = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _types = __webpack_require__("../sjs/src/types.js");

	var _functional = __webpack_require__("../sjs/src/functional.js");

	var _functional2 = _interopRequireDefault(_functional);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var not = _functional2.default.not,
	    curry = _functional2.default.curry,
	    rcompose = _functional2.default.rcompose,
	    maybe = _functional2.default.maybe,
	    asyncAction = _functional2.default.asyncAction,
	    head = _functional2.default.head,
	    tail = _functional2.default.tail,
	    classOf = _functional2.default.classOf;


	var lib = { not: not, curry: curry, rcompose: rcompose, maybe: maybe, asyncAction: asyncAction, head: head, tail: tail };
	lib.getParent = function (node) {
	    return node.parentNode;
	};
	lib.last = function (a) {
	    return tail(a, a.length - 1)[0];
	};
	lib.cloneNode = maybe(function (node) {
	    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    return document.importNode(node, deep);
	});
	lib.handleClass = function (action) {
	    return curry(function (node, className) {
	        var n = lib.cloneNode(node);
	        action.call(n.classList, className);
	        return n;
	    });
	};
	lib.replaceNode = curry(function (oldNode, newNode) {
	    var context = lib.getParent(oldNode);
	    return new Promise(function (resolve) {
	        window.requestAnimationFrame(function () {
	            context.replaceChild(newNode, oldNode);
	            resolve(newNode);
	        });
	    });
	});
	lib.removeClass = lib.handleClass(window.DOMTokenList.prototype.remove);
	lib.addClass = lib.handleClass(window.DOMTokenList.prototype.add);

	lib.maybeValid = function (predicate) {
	    return function (item) {
	        return predicate(item) ? item : null;
	    };
	};

	lib.showItem = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-visible';
	    return lib.replaceNode(i, lib.removeClass(i, cn));
	};
	lib.hideItem = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-visible';
	    return lib.replaceNode(i, lib.removeClass(i, cn));
	};
	lib.activateItem = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-active';
	    return lib.replaceNode(i, lib.addClass(i, cn));
	};
	lib.deactivateItem = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-active';
	    return lib.replaceNode(i, lib.removeClass(i, cn));
	};
	lib.activateLoading = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-loading';
	    return lib.replaceNode(i, lib.addClass(i, cn));
	};
	lib.deactivateLoading = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-loading';
	    return lib.replaceNode(i, lib.removeClass(i, cn));
	};
	lib.setCurrent = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-current';
	    return lib.replaceNode(i, lib.addClass(i, cn));
	};
	lib.unsetCurrent = function (i) {
	    var cn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'is-current';
	    return lib.replaceNode(i, lib.removeClass(i, cn));
	};

	/**
	 * A convenient way to handle Ajax Requests
	 * @param      {(Object)}  requestObj  An object containing the request config
	 * @return     {(Object|Promise)}   An object containing the allowed CRUD
	 *                                  operations. Each operation returns a Promise
	 *                                  which can be used to follow up with its status
	 */
	lib.$http = function (requestObj) {
	    var url = _types.types.str(requestObj.url);
	    var header = requestObj.header;
	    var headerValue = requestObj.headerValue;
	    var core = {
	        ajax: function ajax(method, url) {
	            var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	            method = _types.types.str(method);
	            args = _types.types.obj(args);
	            var promise = new Promise(function (resolve, reject) {
	                var client = new XMLHttpRequest();
	                var uri = url;

	                if (args && (method === 'POST' || method === 'PUT')) {
	                    uri += '?';
	                    var argcount = 0;
	                    var _iteratorNormalCompletion = true;
	                    var _didIteratorError = false;
	                    var _iteratorError = undefined;

	                    try {
	                        for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                            var key = _step.value;

	                            if (argcount++) {
	                                uri += '&';
	                            }
	                            uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]);
	                        }
	                    } catch (err) {
	                        _didIteratorError = true;
	                        _iteratorError = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion && _iterator.return) {
	                                _iterator.return();
	                            }
	                        } finally {
	                            if (_didIteratorError) {
	                                throw _iteratorError;
	                            }
	                        }
	                    }
	                }

	                client.open(method, uri);
	                if (header) {
	                    client.setRequestHeader(header, headerValue);
	                }
	                client.send();

	                client.onload = function () {
	                    if (this.status === 200) {
	                        resolve(this.response);
	                    } else {
	                        reject(this.statusText);
	                    }
	                };
	                client.onerror = function () {
	                    reject(this.statusText);
	                };
	            });

	            return promise;
	        }
	    };

	    return {
	        'get': function get(args) {
	            return core.ajax('GET', url, args);
	        },
	        'post': function post(args) {
	            return core.ajax('POST', url, args);
	        },
	        'put': function put(args) {
	            return core.ajax('PUT', url, args);
	        },
	        'delete': function _delete(args) {
	            return core.ajax('DELETE', url, args);
	        }
	    };
	};

	var Portfolio = {
	    namespace: function namespace(name) {
	        var parts = name.split('.');
	        var ns = this;

	        for (var i = 0, len = parts.length; i < len; i++) {
	            ns[parts[i]] = ns[parts[i]] || {};
	            ns = ns[parts[i]];
	        }

	        return ns;
	    }
	};

	Portfolio.namespace('Utils').cookies = function () {

	    /**
	     * Get the specified cookie from its name of undefined
	     * @param  {string}   name An optional cookie's name
	     * @return {string || undefined}  Returns the value of the intended cookie
	     *                      or undefined
	     */

	    var get = function get(name) {

	        var decodedCookie = decodeURIComponent(document.cookie);
	        var cookies = decodedCookie.split(';');

	        var cookiesMap = cookies.reduce(function (map, curr) {

	            var parts = curr.split('=');

	            map.set(parts[0].trim(), parts[1]);

	            return map;
	        }, new Map());

	        return cookiesMap.get(name);
	    };

	    return {
	        get: get
	    };
	}();

	Portfolio.namespace('Utils').Obj = function () {

	    /**
	     * Check if the provided argument is a Function
	     * @param  {Function}   func A function
	     * @return {Boolean}      true if the argument passed in is a Function
	     *                        false otherwise
	     */

	    var isFunc = function isFunc(func) {
	        return typeof func === 'function';
	    };

	    /**
	     * Convert an Object List to an Array
	     * @param  {Object}   list An Object list
	     * @return {Array}
	     */

	    var toArr = function toArr(list) {
	        return Array.from(list);
	    };

	    return {
	        isFunc: isFunc,
	        toArr: toArr
	    };
	}();

	Portfolio.namespace('Utils').Dom = function () {

	    /**
	     * Return document.documentElement for Chrome and Safari, document.body otherwise
	     * @return {Node}      document.documentElement or document.body
	     */

	    var getBody = function getBody() {
	        var body = void 0;
	        document.documentElement.scrollTop += 1;
	        body = document.documentElement.scrollTop !== 0 ? document.documentElement : document.body;
	        document.documentElement.scrollTop -= 1;
	        return body;
	    };

	    /**
	     * A shorthand of the document.querySelector method
	     * @param  {String}   selector A valid CSS selector
	     * @param  {String}   parent   An optional parent Node
	     * @return {Node}      An HTML node element
	     */

	    var $ = function $(selector, parent) {
	        return (parent || document).querySelector(selector);
	    };

	    /**
	     * A shorthand of the document.querySelectorAll method
	     * @param  {String}   selector A valid CSS selector
	     * @param  {String}   parent   An optional parent Node
	     * @return {Node}      An HTML node List
	     */

	    var $$ = function $$(selector, parent) {
	        return (parent || document).querySelectorAll(selector);
	    };

	    /**
	     * Get the closest matching element up the DOM tree.
	     * @param  {Element} elem     Starting element
	     * @param  {String}  selector Selector to match notwithstanding
	     * @return {Boolean|Element}  Returns null if not match found
	     */
	    var getClosest = function getClosest(elem, selector) {

	        // When elem is a Text node, get its parent node
	        if (elem.nodeType === 3) {
	            elem = elem.parentNode;
	        }

	        // Element.matches() polyfill
	        if (!Element.prototype.matches) {
	            Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
	                var matches = (this.document || this.ownerDocument).querySelectorAll(s),
	                    i = matches.length;
	                while (i >= 0 && matches.item(i) !== this) {
	                    --i;
	                }
	                return i > -1;
	            };
	        }

	        // Get closest match
	        for (; elem && elem !== document; elem = elem.parentNode) {
	            if (elem.matches(selector)) {
	                return elem;
	            }
	        }

	        return null;
	    };

	    /**
	     * Get an element's distance from the top of the page
	     * @param  {Node}   elem The element
	     * @return {Number}      Distance from the of the page
	     */
	    var getElemDistance = function getElemDistance(elem) {
	        var location = 0;
	        if (elem.offsetParent) {
	            do {
	                location += elem.offsetTop;
	                elem = elem.offsetParent;
	            } while (elem);
	        }
	        return location >= 0 ? location : 0;
	    };

	    /**
	     * Get  the values of all the CSS properties of an element after applying
	     * the active stylesheets
	     * @param  {Node}   element The element for which to get the computed style
	     * @return {CSSStyleDeclaration }
	     */
	    var getComputed = function getComputed(element) {
	        return function (property) {
	            return window.getComputedStyle(element, null).getPropertyValue(property);
	        };
	    };

	    return {
	        getBody: getBody,
	        $: $,
	        $$: $$,
	        getClosest: getClosest,
	        getElemDistance: getElemDistance,
	        getComputed: getComputed
	    };
	}();

	Portfolio.namespace('Utils').Window = function () {

	    /**
	     * Give ViewPort Info (height and width)
	     * @param {Object}
	     */

	    function getViewPortInfo() {

	        var body = Portfolio.namespace('Utils').Dom.getBody();
	        var w = Math.max(body.clientWidth, window.innerWidth || 0);
	        var h = Math.max(body.clientHeight, window.innerHeight || 0);

	        return {
	            width: w,
	            height: h
	        };
	    }

	    return {
	        viewPort: getViewPortInfo
	    };
	}();

	Portfolio.namespace('Animation').easings = function () {

	    var easings = {
	        'linear': function linear(t) {
	            return t;
	        },
	        'easeInQuad': function easeInQuad(t) {
	            return t * t;
	        },
	        'easeOutQuad': function easeOutQuad(t) {
	            return t * (2 - t);
	        },
	        'easeInOutQuad': function easeInOutQuad(t) {
	            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
	        },
	        'easeInCubic': function easeInCubic(t) {
	            return t * t * t;
	        },
	        'easeOutCubic': function easeOutCubic(t) {
	            return --t * t * t + 1;
	        },
	        'easeInOutCubic': function easeInOutCubic(t) {
	            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
	        },
	        'easeInQuart': function easeInQuart(t) {
	            return t * t * t * t;
	        },
	        'easeOutQuart': function easeOutQuart(t) {
	            return 1 - --t * t * t * t;
	        },
	        'easeInOutQuart': function easeInOutQuart(t) {
	            return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
	        },
	        'easeInQuint': function easeInQuint(t) {
	            return t * t * t * t * t;
	        },
	        'easeOutQuint': function easeOutQuint(t) {
	            return 1 + --t * t * t * t * t;
	        },
	        'easeInOutQuint': function easeInOutQuint(t) {
	            return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
	        }
	    };

	    /**
	     * Get an easing function
	     * @param  {String}   The easing function's name you are looking for
	     * @return {Function} The easing function (if any) or linear (default)
	     */

	    var getEasing = function getEasing() {
	        var easing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'linear';
	        return easings[easing];
	    };

	    return getEasing;
	}();

	Portfolio.namespace('Animation').scrolling = function () {

	    /**
	     * Scroll the window to the element position
	     * @param  {Node}   element An HTML node towards which you wish to scroll
	                                the window
	     * @param  {Object}  options Animation's options (easing type and duration)
	     * @param {Function} callback An optional callback
	     */

	    var scrollTo = function scrollTo(element, options, callback) {
	        options = options || {};
	        var obj = Portfolio.namespace('Utils').Obj;
	        var dom = Portfolio.namespace('Utils').Dom;
	        var easings = Portfolio.namespace('Animation').easings;

	        var body = dom.getBody();
	        var start = body.scrollTop;
	        var startTime = Date.now();
	        var destination = dom.getElemDistance(element);
	        var easing = options.ease;
	        var duration = options.duration || 200;

	        function scroll() {
	            var now = Date.now();
	            var time = Math.min(1, (now - startTime) / duration);
	            var timeFunction = easings(easing)(time);

	            body.scrollTop = timeFunction * (destination - start) + start;

	            if (Math.ceil(body.scrollTop) === destination) {
	                if (obj.isFunc(callback)) {
	                    callback();
	                }

	                return;
	            }
	            requestAnimationFrame(scroll);
	        }
	        scroll();
	    };

	    return {
	        scrollTo: scrollTo
	    };
	}();

	Portfolio.namespace('Utils').Forms = function () {

	    var _toArray = function _toArray(i) {
	        return classOf(i) === 'Array' ? i : [i];
	    };

	    /**
	     * Validates input
	     * @param      {(HTMLNode)}  input  The input to be validate
	     * @return     {(Array)}   An Array of errors
	     */
	    var _reduceV = function _reduceV(input) {
	        return function (messages, Validator) {
	            var instance = new Validator();
	            var isValid = instance.validate(input);
	            if (isValid === false) {
	                messages.push(instance.getMessage());
	            }
	            return messages;
	        };
	    };

	    /**
	     * A class used to collect inputs for a subsequent validation
	     */

	    var Validator = function () {
	        function Validator() {
	            _classCallCheck(this, Validator);

	            this.validationMap = new Map();
	        }

	        _createClass(Validator, [{
	            key: 'setValidators',
	            value: function setValidators(input, validators) {
	                this.validationMap.set(input, _toArray(validators));
	            }
	        }, {
	            key: 'validate',
	            value: function validate(input) {
	                var validators = this.validationMap.get(input);
	                var result = {};
	                if (validators) {
	                    var checks = _reduceV(input);
	                    var errors = [].reduce.call(validators, checks, []);
	                    result.input = input;
	                    result.errors = errors;
	                }
	                return result;
	            }
	        }, {
	            key: 'validateAll',
	            value: function validateAll() {
	                var results = [];
	                this.validationMap.forEach(function (validators, input) {
	                    var checks = _reduceV(input);
	                    var errors = validators.reduce(checks, []);
	                    results.push({
	                        input: input,
	                        errors: errors
	                    });
	                });

	                return results;
	            }
	        }]);

	        return Validator;
	    }();

	    /**
	     * A base class used to validate custom Validators
	     */


	    var Validation = function () {
	        function Validation() {
	            _classCallCheck(this, Validation);
	        }

	        _createClass(Validation, [{
	            key: 'validate',
	            value: function validate(input) {
	                return this.re.test(input.value);
	            }
	        }, {
	            key: 'getMessage',
	            value: function getMessage() {
	                return this.message;
	            }
	        }, {
	            key: 'setMessage',
	            value: function setMessage(message) {
	                this.message = message;
	            }
	        }]);

	        return Validation;
	    }();

	    /**
	     * A Validator class used to validate empty strings
	     */


	    var _NotEmpty = function (_Validation) {
	        _inherits(NotEmpty, _Validation);

	        function NotEmpty() {
	            _classCallCheck(this, NotEmpty);

	            var _this = _possibleConstructorReturn(this, (NotEmpty.__proto__ || Object.getPrototypeOf(NotEmpty)).call(this));

	            _this.re = /^\s*$/;
	            _this.message = 'Empty Field';
	            return _this;
	        }

	        _createClass(NotEmpty, [{
	            key: 'validate',
	            value: function validate(input) {
	                return !this.re.test(input.value);
	            }
	        }]);

	        return NotEmpty;
	    }(Validation);

	    /**
	     * A Validator class used to validate emails
	     */


	    var _Email = function (_Validation2) {
	        _inherits(Email, _Validation2);

	        function Email() {
	            _classCallCheck(this, Email);

	            var _this2 = _possibleConstructorReturn(this, (Email.__proto__ || Object.getPrototypeOf(Email)).call(this));

	            _this2.re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	            _this2.message = 'Invalid Email';
	            return _this2;
	        }

	        return Email;
	    }(Validation);

	    return {
	        Validator: Validator,
	        NotEmpty: function NotEmpty() {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            return new (Function.prototype.bind.apply(_NotEmpty, [null].concat(args)))();
	        },
	        Email: function Email() {
	            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                args[_key2] = arguments[_key2];
	            }

	            return new (Function.prototype.bind.apply(_Email, [null].concat(args)))();
	        }
	    };
	}();

	exports.Portfolio = Portfolio;
	exports.lib = lib;

/***/ }),

/***/ "./src/components/tab/tab.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lib = __webpack_require__("./src/js/lib.js");

	var not = _lib.lib.not,
	    curry = _lib.lib.curry,
	    maybe = _lib.lib.maybe,
	    maybeValid = _lib.lib.maybeValid,
	    deactivateItem = _lib.lib.deactivateItem,
	    activateItem = _lib.lib.activateItem,
	    getParent = _lib.lib.getParent;

	/**
	 * Defines what makes an item valid when a user clicks it
	 * @type  {HTMLNode} activeItem  The current active tab item
	 * @type  {HTMLNode} clickedItem  The tab label that was clicked by the user
	 * @returns {Bool} True if the clicked item is valid, False if not
	 */

	var predicate = curry(function (activeItem, clickedItem) {
	  return clickedItem.classList.contains('c-tab__label') && not(clickedItem.classList.contains('c-tab__label--sticket')) && clickedItem !== activeItem;
	});

	/**
	 * Define what System does when a user clicks on a valid tab item
	 * @type  {HTMLNode} target  The item that was just clicked
	 * @type  {HTMLNode} activeItem  The active item
	 * @returns {void 0}
	 */
	var clickItem = maybe(function (target, activeItem) {
	  var tabItem = getParent(target);
	  deactivateItem(activeItem);
	  activateItem(tabItem);
	});

	/**
	 * Defines the Tab event handler
	 */
	function tabHandler(e) {
	  var activeLabel = e.currentTarget.querySelector('.is-active .c-tab__label');
	  var activeItem = getParent(activeLabel);
	  var target = maybeValid(predicate(activeLabel))(e.target);
	  clickItem(target, activeItem);
	}

	exports.default = tabHandler;

/***/ }),

/***/ "./src/components/card/card.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lib = __webpack_require__("./src/js/lib.js");

	var rcompose = _lib.lib.rcompose,
	    cloneNode = _lib.lib.cloneNode,
	    replaceNode = _lib.lib.replaceNode;

	var DOM = _lib.Portfolio.Utils.Dom;

	/**
	 * Takes the node having the '.c-card' class
	 *
	 * @param      {Event}  e  The click Event
	 * @return     {HTMLNode}  The card component
	 */
	var takeTheCard = function takeTheCard(e) {
	  return e.target === e.currentTarget ? e.target : DOM.getClosest(e.target, '.c-card');
	};

	/**
	 * Takes the trigger of the Card flip animation
	 *
	 * @param      {HTMLNode}  c    The card component
	 * @return     {HTMLInputElement}  The input element used as trigger
	 */
	var takeTheTrigger = function takeTheTrigger(c) {
	  return c.parentNode.querySelector('.c-businessCard__input--trigger');
	};

	/**
	 * Changes the current status of the trigger
	 *
	 * @param      {HTMLInputElement}  i   The input used as a trigger
	 * @return     {Object}  An object containing the old input and its clone
	 */
	var switchTriggerStatus = function switchTriggerStatus(i) {
	  var clone = cloneNode(i);
	  // Invert the status
	  clone.checked = !i.checked;
	  return {
	    prevTrigger: i,
	    newTrigger: clone
	  };
	};

	/**
	 * Replaces an existing Node with a new Node
	 *
	 * @param      {Object}  o  An Object containing the triggers
	 */
	var replaceTrigger = function replaceTrigger(o) {
	  replaceNode(o.prevTrigger, o.newTrigger);
	};

	/**
	 * Event handler
	 *
	 * @param      {Event}  e       The click event
	 */
	function cardHandler(e) {
	  var run = rcompose(takeTheCard, takeTheTrigger, switchTriggerStatus, replaceTrigger);
	  run(e);
	}

	exports.default = cardHandler;

/***/ }),

/***/ "./src/components/email/email.js":
/***/ (function(module, exports, __webpack_require__) {

	/*global emailjs UIProgressButton*/
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lib = __webpack_require__("./src/js/lib.js");

	var getParent = _lib.lib.getParent;

	var FORM = _lib.Portfolio.Utils.Forms;
	var DOM = _lib.Portfolio.Utils.Dom;

	var emailForm = DOM.$('.c-form[name="concact"]');
	var dir = 'components/email/';

	var successHTML = '<div class="c-form__result">\n                      <img src="' + dir + '/img/sent_icon.png" title="Sent Icon" />\n                      <p>Thank you for contanct me</p>\n                      <p>I will replay as soon as possible</p>\n                    </div>';

	var errorHTML = function errorHTML(err) {
	  var message = JSON.parse(err.text);
	  return '<div class="c-form__result">\n            <img src="' + dir + '/img/opss_icon.png" title="Sent Icon" />\n            <p>Opss something went wrong!</p>\n            <p>The Server says:</p>\n            <p class="error">' + message.error + '</p>\n            <p>Please try again</p>\n          </div>';
	};

	var validator = null;
	var _interval = void 0;
	var _submitButton = void 0;

	var setFieldAsInvalid = function setFieldAsInvalid(field) {
	  field.classList.add('is-invalid');
	};

	var setFieldAsValid = function setFieldAsValid(field) {
	  field.classList.remove('is-invalid');
	};

	/**
	 * Generates an unordered list containing all the catched errors
	 * @param      {(Array)}  errors  An Array of errors
	 * @returns   {String}            A string representation
	 */
	var generateErrorsList = function generateErrorsList(errors) {
	  var list = '<ul>';
	  errors.forEach(function (error) {
	    return list += '<li>' + error + '</li>';
	  });
	  list += '</ul>';
	  return list;
	};

	/**
	 * Handles the result of the validation
	 * @param      {(Array)}  fields  An Array of objects
	 * @returns   {Promise}            A promise
	 */
	var handleValidation = function handleValidation(fields) {
	  return new Promise(function (resolve, reject) {
	    var count = 0;
	    fields.forEach(function (field) {
	      var parent = getParent(field.input);
	      var list = parent.firstElementChild;
	      var errors = field.errors;
	      if (errors.length > 0) {
	        setFieldAsInvalid(parent);
	        list.innerHTML = generateErrorsList(errors);
	        count += errors.length;
	      } else {
	        // Remove invalid fields (if necessary)
	        setFieldAsValid(parent);
	        list.innerHTML = '';
	      }
	    });

	    if (count > 0) {
	      reject();
	    } else {
	      resolve();
	    }
	  });
	};

	var clearResultMessage = function clearResultMessage() {
	  window.setTimeout(function () {
	    DOM.$('.c-form__result', emailForm).remove();
	  }, 4000);
	};

	/**
	 * Sends an email when inputs are valid
	 * @returns   {void 0}
	 */
	var sendEmail = function sendEmail() {
	  _submitButton.getInstance()._submit();
	  emailjs.init('user_aUOPsQzuTNdTRPcxZ6pXS');
	  emailjs.sendForm('default_service', 'template_ctNudcMa', 'contact-form').then(function (response) {
	    _submitButton.getInstance().stop(1);
	    emailForm.insertAdjacentHTML('afterbegin', successHTML);
	    emailForm.reset();
	  }, function (err) {
	    _submitButton.getInstance().stop(-1);
	    emailForm.insertAdjacentHTML('afterbegin', errorHTML(err));
	  }).then(function () {
	    clearInterval(_interval);
	    clearResultMessage();
	  });
	};

	/**
	 * A handler function to prevent default submission and run our custom script.
	 * @param  {Event} event  the submit event triggered by the user
	 * @return {void}
	 */
	var handleEmail = function handleEmail(event) {

	  event.preventDefault();

	  var fields = validator.validateAll();

	  handleValidation(fields).then(sendEmail).catch(function () {
	    _submitButton.getInstance().stop(-1);
	  });
	};

	/**
	 * Initialises the Validator for the contact form
	 * @returns   {void 0}
	 */
	var init = function init() {
	  var emailButton = getParent(DOM.$('#button--contact'));
	  var name = emailForm.elements.name;
	  var email = emailForm.elements.email;
	  var message = emailForm.elements.message;
	  validator = new FORM.Validator();
	  validator.setValidators(name, FORM.NotEmpty);
	  validator.setValidators(email, FORM.Email);
	  validator.setValidators(message, FORM.NotEmpty);
	  _submitButton = new UIProgressButton(emailButton, {
	    callback: function callback(instance) {
	      var progress = 0;
	      _interval = window.setInterval(function () {
	        progress = Math.min(progress + Math.random() * 0.1, 1);
	        instance.setProgress(progress);
	        if (progress === 1) {
	          // Restart the progression
	          progress = 0;
	        }
	      }, 150);
	    }
	  });
	};

	exports.default = {
	  init: init,
	  handleEmail: handleEmail
	};

/***/ }),

/***/ "./src/components/trivia/trivia.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lib = __webpack_require__("./src/js/lib.js");

	var maybe = _lib.lib.maybe,
	    maybeValid = _lib.lib.maybeValid,
	    activateLoading = _lib.lib.activateLoading,
	    deactivateLoading = _lib.lib.deactivateLoading,
	    $http = _lib.lib.$http,
	    tail = _lib.lib.tail;

	var _$ = _lib.Portfolio.Utils.Dom.$;

	/**
	 * Starts the loading animation by adding a specific CSS class on the item
	 * @param       {HTMLNode} item The item to be animated
	 * @returns     {Promise} Returns a Promise which, in turns, returns a new
	 *                        HTMLNode having the animation class
	 */
	var startLoadingAnimation = maybe(function (item) {
	  return activateLoading(item);
	});

	/**
	 * Stops the loading animation by removing a specific CSS class on the item
	 * @param       {HTMLNode} item The animated item
	 * @returns     {Promise} Returns a Promise which, in turns, returns a new
	 *                        HTMLNode without the animation class
	 */
	var stopLoadingAnimation = maybe(function (item) {
	  return deactivateLoading(item);
	});

	/**
	 * Defines what makes an item to be valid when a user clicks it
	 * @param  {HTMLNode} item  The item that was clicked by a user
	 * @returns {Bool} True if the clicked item is valid, False if not
	 */
	var predicate = maybe(function (item) {
	  return item.nodeName === 'I';
	});

	/**
	 * Generates a random integer
	 *
	 * @return     {Integer}  A random integer between 0 and 200
	 */
	var randomInteger = function randomInteger() {
	  return Math.floor(Math.random() * 200);
	};

	var apiReq = function apiReq() {
	  return $http({
	    url: 'https://numbersapi.p.mashape.com/' + randomInteger(),
	    header: 'X-Mashape-Authorization',
	    headerValue: 'cCRn3ndWPPmshXp3hZ6finUK92HIp10pB2sjsne4SUvAkUkoCz'
	  });
	};

	var callback = {
	  success: function success(data) {
	    var parts = data.substr(0, data.length - 1).split(' ');
	    var msg = 'Did you know that\n              <span class="c-random-fact__number">' + parts[0] + '</span>\n              ' + tail(parts).join(' ') + ' ?';
	    _$('.c-random-fact__paragraph').innerHTML = msg;
	  },
	  error: function error() {
	    _$('.c-random-fact__paragraph').innerHTML = 'Trivia is temporarily unavailable.\n                                                 I\'m Sorry.';
	  }
	};

	/**
	 * Retrieves a random fact through an initial API request
	 */
	function init() {
	  apiReq().get().then(callback.success).catch(callback.error);
	}

	/**
	 * Handles clicks only when the clicked item satisfies the Trivia's predicate
	 *
	 * @type       {HTMLNode} target The clicked item must be the loading icon
	 */
	var handleClick = maybe(function (target) {
	  startLoadingAnimation(target).then(function (node) {
	    apiReq().get().then(callback.success).catch(callback.error).then(function () {
	      stopLoadingAnimation(node);
	    });
	  });
	});

	/**
	 * Handles click events on the Trivia component.
	 * The clicked item must satisfy the Trivia's predicate otherwise the event
	 * is discarded.
	 *
	 * @param      {Event}  e       A click event
	 */
	function handler(e) {
	  handleClick(maybeValid(predicate)(e.target));
	}

	exports.default = {
	  init: init,
	  handler: handler
	};

/***/ }),

/***/ "./src/components/sideMenu/sideMenu.js":
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lib = __webpack_require__("./src/js/lib.js");

	var curry = _lib.lib.curry,
	    rcompose = _lib.lib.rcompose,
	    maybe = _lib.lib.maybe,
	    maybeValid = _lib.lib.maybeValid,
	    last = _lib.lib.last,
	    setCurrent = _lib.lib.setCurrent,
	    unsetCurrent = _lib.lib.unsetCurrent;

	var DOM = _lib.Portfolio.Utils.Dom;

	var DOMCACHE = {
	  sideMenuMobileTrigger: DOM.$('#hamburger__checkbox')
	};

	/**
	 * Starts the loading animation by adding a specific CSS class on the item
	 * @param       {HTMLNode} item The item to be animated
	 * @returns     {Promise} Returns a Promise which, in turns, returns a new
	 *                        HTMLNode having the animation class
	 */
	var setAsCurrent = maybe(function (item) {
	  return setCurrent(item);
	});

	/**
	 * Stops the loading animation by removing a specific CSS class on the item
	 * @param       {HTMLNode} item The animated item
	 * @returns     {Promise} Returns a Promise which, in turns, returns a new
	 *                        HTMLNode without the animation class
	 */
	var unsetAsCurrent = maybe(function (item) {
	  return unsetCurrent(item);
	});

	/**
	 * Retrieves the coordinates of a HTMLNode
	 * @param       {HTMLNode} item The node to be analyzed
	 * @returns     {Object} Returns an object containing
	 */
	var getNodeCoords = function getNodeCoords(node) {
	  return {
	    id: node.id,
	    coords: DOM.getElemDistance(node)
	  };
	};

	/**
	 * Gets an item through its coordinates
	 * @type  {HTMLNodeList} nodes  A list of HTML nodes
	 * @type  {NUMBER} position  The position of the item you're looking for
	 */
	var getItemByPosition = curry(function (nodes, position) {
	  var list = Array.from(nodes).map(getNodeCoords).filter(function (node) {
	    return node.coords <= position;
	  });
	  return last(list);
	});

	/**
	 * Gets the id property from an object
	 * @type  {Object} o  The object containing an id property
	 */
	var getID = function getID(o) {
	  return o.id;
	};

	/**
	 * Gets a link through its unique identifier
	 * @type  {STRING} id  The section's identifier
	 */
	var getLinkByID = function getLinkByID(id) {
	  return DOM.$('.c-sideMenu__link[href="#' + id + '"]');
	};

	/**
	 * Sets an item as the current one
	 * @type  {HTMLNode} link  The '.c-sideMenu__link' where an item belongs
	 */
	var setCurrentItem = maybe(function (link) {
	  var menuCard = DOM.getClosest(link, '.c-menucard');
	  var dotNav = DOM.$('.c-dotNav', menuCard);
	  var currentLink = DOM.$('.c-sideMenu__link.is-current');
	  var currentNav = DOM.$('.c-dotNav.is-current');

	  if (currentLink.textContent === link.textContent) {
	    return;
	  }

	  unsetAsCurrent(currentLink).then(function () {
	    setAsCurrent(link);
	  });

	  unsetAsCurrent(currentNav).then(function () {
	    setAsCurrent(dotNav);
	  });
	});

	/**
	 * Defines to set an item through its position
	 * @type  {Number} position  The item's position
	 */
	var setCurrentItemByPosition = function setCurrentItemByPosition(position) {
	  var findItem = getItemByPosition(DOM.$$('main .c-section'));

	  var run = rcompose(findItem, getID, getLinkByID, setCurrentItem);

	  run(position);
	};

	/**
	 * Defines what makes an item valid when a user clicks it
	 * @type  {HTMLNode} clickedItem  The clicked link
	 * @returns {Bool} True if the clicked item is valid, False if not
	 */
	var predicate = function predicate(clickedItem) {
	  return clickedItem.nodeName === 'A';
	};

	/**
	 * Scrolls the Window to an HTML item
	 * @type  {HTMLNode} elem  An HTML Node
	 */
	var scrollToElem = maybe(function (elem) {
	  var delay = window.setInterval(function () {
	    _lib.Portfolio.Animation.scrolling.scrollTo(elem);
	    window.clearInterval(delay);
	  }, 300);
	});

	/**
	 * Handles the click to an intended HTML item
	 * @type  {HTMLNode} target  An HTML Node
	 */
	var mobileClick = maybe(function (target) {
	  var targetSelector = target.getAttribute('href');
	  var targetElement = DOM.$(targetSelector);
	  //When a user clicks on a link, close the menu
	  DOMCACHE.sideMenuMobileTrigger.checked = false;
	  scrollToElem(targetElement);
	});

	/**
	 * Handles the click event and runs the actions only if the clicked element
	 * passes the predicate
	 * @type  {Event} e  The click Event
	 */
	function mobileClickHandler(e) {
	  e.stopPropagation();
	  e.preventDefault();
	  var target = maybeValid(predicate)(e.target);
	  mobileClick(target);
	}

	exports.default = {
	  setCurrentItemByPosition: setCurrentItemByPosition,
	  mobileClickHandler: mobileClickHandler
	};

/***/ })

/******/ });